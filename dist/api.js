"use strict";
// tslint:disable
/**
 * Trata AI API
 * Human like conversation to answer calls, drive engagement, automate follow-ups & schedule bookings 24/7  with end to end integrations ensuring you never miss a sales enquiry.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VoiceModelsApi = exports.VoiceModelsApiFactory = exports.VoiceModelsApiFp = exports.VoiceModelsApiAxiosParamCreator = exports.UIApi = exports.UIApiFactory = exports.UIApiFp = exports.UIApiAxiosParamCreator = exports.TelephonyApi = exports.TelephonyApiFactory = exports.TelephonyApiFp = exports.TelephonyApiAxiosParamCreator = exports.ResellerApi = exports.ResellerApiFactory = exports.ResellerApiFp = exports.ResellerApiAxiosParamCreator = exports.ProspectsApi = exports.ProspectsApiFactory = exports.ProspectsApiFp = exports.ProspectsApiAxiosParamCreator = exports.ProductsApi = exports.ProductsApiFactory = exports.ProductsApiFp = exports.ProductsApiAxiosParamCreator = exports.InternalApi = exports.InternalApiFactory = exports.InternalApiFp = exports.InternalApiAxiosParamCreator = exports.HiveAgentLinkApi = exports.HiveAgentLinkApiFactory = exports.HiveAgentLinkApiFp = exports.HiveAgentLinkApiAxiosParamCreator = exports.HiveApi = exports.HiveApiFactory = exports.HiveApiFp = exports.HiveApiAxiosParamCreator = exports.HealthApi = exports.HealthApiFactory = exports.HealthApiFp = exports.HealthApiAxiosParamCreator = exports.FilesApi = exports.FilesApiFactory = exports.FilesApiFp = exports.FilesApiAxiosParamCreator = exports.DataPlaneApi = exports.DataPlaneApiFactory = exports.DataPlaneApiFp = exports.DataPlaneApiAxiosParamCreator = exports.ConversationsApi = exports.ConversationsApiFactory = exports.ConversationsApiFp = exports.ConversationsApiAxiosParamCreator = exports.ConversationProspectLinkApi = exports.ConversationProspectLinkApiFactory = exports.ConversationProspectLinkApiFp = exports.ConversationProspectLinkApiAxiosParamCreator = exports.BillingApi = exports.BillingApiFactory = exports.BillingApiFp = exports.BillingApiAxiosParamCreator = exports.ApiKeyApi = exports.ApiKeyApiFactory = exports.ApiKeyApiFp = exports.ApiKeyApiAxiosParamCreator = exports.AnalyticsApi = exports.AnalyticsApiFactory = exports.AnalyticsApiFp = exports.AnalyticsApiAxiosParamCreator = exports.AgentsApi = exports.AgentsApiFactory = exports.AgentsApiFp = exports.AgentsApiAxiosParamCreator = exports.ActionsApi = exports.ActionsApiFactory = exports.ActionsApiFp = exports.ActionsApiAxiosParamCreator = exports.ActionAgentLinkApi = exports.ActionAgentLinkApiFactory = exports.ActionAgentLinkApiFp = exports.ActionAgentLinkApiAxiosParamCreator = exports.VoiceOutputGenderEnum = exports.VoiceInputGenderEnum = exports.Status = exports.SortOrder = exports.Role = exports.ProspectStatus = exports.ProductInputCurrencyEnum = exports.MetricName = exports.Language = exports.HttpActionEndpointMethodEnum = exports.HiveType = exports.ConversationStartEventPayloadTypeEnum = exports.ConversationSourceType = exports.ConnectionSourceSourceNameEnum = exports.CallSentiment = exports.AggregationPeriod = exports.AggregationFormula = exports.ActionInvocationTrigger = exports.Accent = void 0;
const globalImportUrl = require("url");
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const base_1 = require("./base");
/**
 *
 * @export
 * @enum {string}
 */
var Accent;
(function (Accent) {
    Accent["American"] = "American";
    Accent["Indian"] = "Indian";
    Accent["Australian"] = "Australian";
    Accent["British"] = "British";
    Accent["Hindi"] = "Hindi";
})(Accent = exports.Accent || (exports.Accent = {}));
/**
 *
 * @export
 * @enum {string}
 */
var ActionInvocationTrigger;
(function (ActionInvocationTrigger) {
    ActionInvocationTrigger["UserQuery"] = "user_query";
    ActionInvocationTrigger["WebhookConversationStart"] = "webhook.conversation_start";
    ActionInvocationTrigger["WebhookConversationEnd"] = "webhook.conversation_end";
})(ActionInvocationTrigger = exports.ActionInvocationTrigger || (exports.ActionInvocationTrigger = {}));
/**
 *
 * @export
 * @enum {string}
 */
var AggregationFormula;
(function (AggregationFormula) {
    AggregationFormula["COUNT"] = "COUNT";
    AggregationFormula["SUM"] = "SUM";
    AggregationFormula["MEDIAN"] = "MEDIAN";
})(AggregationFormula = exports.AggregationFormula || (exports.AggregationFormula = {}));
/**
 *
 * @export
 * @enum {string}
 */
var AggregationPeriod;
(function (AggregationPeriod) {
    AggregationPeriod["MONTHLY"] = "MONTHLY";
    AggregationPeriod["WEEKLY"] = "WEEKLY";
    AggregationPeriod["DAILY"] = "DAILY";
})(AggregationPeriod = exports.AggregationPeriod || (exports.AggregationPeriod = {}));
/**
 *
 * @export
 * @enum {string}
 */
var CallSentiment;
(function (CallSentiment) {
    CallSentiment["Positive"] = "positive";
    CallSentiment["Negative"] = "negative";
    CallSentiment["Neutral"] = "neutral";
})(CallSentiment = exports.CallSentiment || (exports.CallSentiment = {}));
/**
    * @export
    * @enum {string}
    */
var ConnectionSourceSourceNameEnum;
(function (ConnectionSourceSourceNameEnum) {
    ConnectionSourceSourceNameEnum["TWILIO"] = "TWILIO";
    ConnectionSourceSourceNameEnum["PLIVO"] = "PLIVO";
    ConnectionSourceSourceNameEnum["BROWSER"] = "BROWSER";
})(ConnectionSourceSourceNameEnum = exports.ConnectionSourceSourceNameEnum || (exports.ConnectionSourceSourceNameEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var ConversationSourceType;
(function (ConversationSourceType) {
    ConversationSourceType["BROWSER"] = "BROWSER";
    ConversationSourceType["TWILIO"] = "TWILIO";
    ConversationSourceType["PLIVO"] = "PLIVO";
})(ConversationSourceType = exports.ConversationSourceType || (exports.ConversationSourceType = {}));
/**
    * @export
    * @enum {string}
    */
var ConversationStartEventPayloadTypeEnum;
(function (ConversationStartEventPayloadTypeEnum) {
    ConversationStartEventPayloadTypeEnum["ConversationStart"] = "conversation_start";
})(ConversationStartEventPayloadTypeEnum = exports.ConversationStartEventPayloadTypeEnum || (exports.ConversationStartEventPayloadTypeEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var HiveType;
(function (HiveType) {
    HiveType["WEBSITE"] = "WEBSITE";
    HiveType["GOOGLEDOCS"] = "GOOGLE_DOCS";
    HiveType["DOCS"] = "DOCS";
    HiveType["TRANSCRIPTS"] = "TRANSCRIPTS";
})(HiveType = exports.HiveType || (exports.HiveType = {}));
/**
    * @export
    * @enum {string}
    */
var HttpActionEndpointMethodEnum;
(function (HttpActionEndpointMethodEnum) {
    HttpActionEndpointMethodEnum["GET"] = "GET";
    HttpActionEndpointMethodEnum["POST"] = "POST";
})(HttpActionEndpointMethodEnum = exports.HttpActionEndpointMethodEnum || (exports.HttpActionEndpointMethodEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var Language;
(function (Language) {
    Language["English"] = "English";
    Language["Spanish"] = "Spanish";
    Language["Hindi"] = "Hindi";
})(Language = exports.Language || (exports.Language = {}));
/**
 *
 * @export
 * @enum {string}
 */
var MetricName;
(function (MetricName) {
    MetricName["CALLS"] = "CALLS";
    MetricName["CALLDURATION"] = "CALL_DURATION";
    MetricName["APPOINTMENTSCHEDULED"] = "APPOINTMENT_SCHEDULED";
    MetricName["PROSPECTS"] = "PROSPECTS";
    MetricName["INTERESTED"] = "INTERESTED";
    MetricName["NOTINTERESTED"] = "NOT_INTERESTED";
})(MetricName = exports.MetricName || (exports.MetricName = {}));
/**
    * @export
    * @enum {string}
    */
var ProductInputCurrencyEnum;
(function (ProductInputCurrencyEnum) {
    ProductInputCurrencyEnum["AED"] = "AED";
    ProductInputCurrencyEnum["AFN"] = "AFN";
    ProductInputCurrencyEnum["ALL"] = "ALL";
    ProductInputCurrencyEnum["AMD"] = "AMD";
    ProductInputCurrencyEnum["ANG"] = "ANG";
    ProductInputCurrencyEnum["AOA"] = "AOA";
    ProductInputCurrencyEnum["ARS"] = "ARS";
    ProductInputCurrencyEnum["AUD"] = "AUD";
    ProductInputCurrencyEnum["AWG"] = "AWG";
    ProductInputCurrencyEnum["AZN"] = "AZN";
    ProductInputCurrencyEnum["BAM"] = "BAM";
    ProductInputCurrencyEnum["BBD"] = "BBD";
    ProductInputCurrencyEnum["BDT"] = "BDT";
    ProductInputCurrencyEnum["BGN"] = "BGN";
    ProductInputCurrencyEnum["BHD"] = "BHD";
    ProductInputCurrencyEnum["BIF"] = "BIF";
    ProductInputCurrencyEnum["BMD"] = "BMD";
    ProductInputCurrencyEnum["BND"] = "BND";
    ProductInputCurrencyEnum["BOB"] = "BOB";
    ProductInputCurrencyEnum["BOV"] = "BOV";
    ProductInputCurrencyEnum["BRL"] = "BRL";
    ProductInputCurrencyEnum["BSD"] = "BSD";
    ProductInputCurrencyEnum["BTN"] = "BTN";
    ProductInputCurrencyEnum["BWP"] = "BWP";
    ProductInputCurrencyEnum["BYN"] = "BYN";
    ProductInputCurrencyEnum["BZD"] = "BZD";
    ProductInputCurrencyEnum["CAD"] = "CAD";
    ProductInputCurrencyEnum["CDF"] = "CDF";
    ProductInputCurrencyEnum["CHE"] = "CHE";
    ProductInputCurrencyEnum["CHF"] = "CHF";
    ProductInputCurrencyEnum["CHW"] = "CHW";
    ProductInputCurrencyEnum["CLF"] = "CLF";
    ProductInputCurrencyEnum["CLP"] = "CLP";
    ProductInputCurrencyEnum["CNY"] = "CNY";
    ProductInputCurrencyEnum["COP"] = "COP";
    ProductInputCurrencyEnum["COU"] = "COU";
    ProductInputCurrencyEnum["CRC"] = "CRC";
    ProductInputCurrencyEnum["CUC"] = "CUC";
    ProductInputCurrencyEnum["CUP"] = "CUP";
    ProductInputCurrencyEnum["CVE"] = "CVE";
    ProductInputCurrencyEnum["CZK"] = "CZK";
    ProductInputCurrencyEnum["DJF"] = "DJF";
    ProductInputCurrencyEnum["DKK"] = "DKK";
    ProductInputCurrencyEnum["DOP"] = "DOP";
    ProductInputCurrencyEnum["DZD"] = "DZD";
    ProductInputCurrencyEnum["EGP"] = "EGP";
    ProductInputCurrencyEnum["ERN"] = "ERN";
    ProductInputCurrencyEnum["ETB"] = "ETB";
    ProductInputCurrencyEnum["EUR"] = "EUR";
    ProductInputCurrencyEnum["FJD"] = "FJD";
    ProductInputCurrencyEnum["FKP"] = "FKP";
    ProductInputCurrencyEnum["GBP"] = "GBP";
    ProductInputCurrencyEnum["GEL"] = "GEL";
    ProductInputCurrencyEnum["GHS"] = "GHS";
    ProductInputCurrencyEnum["GIP"] = "GIP";
    ProductInputCurrencyEnum["GMD"] = "GMD";
    ProductInputCurrencyEnum["GNF"] = "GNF";
    ProductInputCurrencyEnum["GTQ"] = "GTQ";
    ProductInputCurrencyEnum["GYD"] = "GYD";
    ProductInputCurrencyEnum["HKD"] = "HKD";
    ProductInputCurrencyEnum["HNL"] = "HNL";
    ProductInputCurrencyEnum["HRK"] = "HRK";
    ProductInputCurrencyEnum["HTG"] = "HTG";
    ProductInputCurrencyEnum["HUF"] = "HUF";
    ProductInputCurrencyEnum["IDR"] = "IDR";
    ProductInputCurrencyEnum["ILS"] = "ILS";
    ProductInputCurrencyEnum["INR"] = "INR";
    ProductInputCurrencyEnum["IQD"] = "IQD";
    ProductInputCurrencyEnum["IRR"] = "IRR";
    ProductInputCurrencyEnum["ISK"] = "ISK";
    ProductInputCurrencyEnum["JMD"] = "JMD";
    ProductInputCurrencyEnum["JOD"] = "JOD";
    ProductInputCurrencyEnum["JPY"] = "JPY";
    ProductInputCurrencyEnum["KES"] = "KES";
    ProductInputCurrencyEnum["KGS"] = "KGS";
    ProductInputCurrencyEnum["KHR"] = "KHR";
    ProductInputCurrencyEnum["KMF"] = "KMF";
    ProductInputCurrencyEnum["KPW"] = "KPW";
    ProductInputCurrencyEnum["KRW"] = "KRW";
    ProductInputCurrencyEnum["KWD"] = "KWD";
    ProductInputCurrencyEnum["KYD"] = "KYD";
    ProductInputCurrencyEnum["KZT"] = "KZT";
    ProductInputCurrencyEnum["LAK"] = "LAK";
    ProductInputCurrencyEnum["LBP"] = "LBP";
    ProductInputCurrencyEnum["LKR"] = "LKR";
    ProductInputCurrencyEnum["LRD"] = "LRD";
    ProductInputCurrencyEnum["LSL"] = "LSL";
    ProductInputCurrencyEnum["LYD"] = "LYD";
    ProductInputCurrencyEnum["MAD"] = "MAD";
    ProductInputCurrencyEnum["MDL"] = "MDL";
    ProductInputCurrencyEnum["MGA"] = "MGA";
    ProductInputCurrencyEnum["MKD"] = "MKD";
    ProductInputCurrencyEnum["MMK"] = "MMK";
    ProductInputCurrencyEnum["MNT"] = "MNT";
    ProductInputCurrencyEnum["MOP"] = "MOP";
    ProductInputCurrencyEnum["MRU"] = "MRU";
    ProductInputCurrencyEnum["MUR"] = "MUR";
    ProductInputCurrencyEnum["MVR"] = "MVR";
    ProductInputCurrencyEnum["MWK"] = "MWK";
    ProductInputCurrencyEnum["MXN"] = "MXN";
    ProductInputCurrencyEnum["MXV"] = "MXV";
    ProductInputCurrencyEnum["MYR"] = "MYR";
    ProductInputCurrencyEnum["MZN"] = "MZN";
    ProductInputCurrencyEnum["NAD"] = "NAD";
    ProductInputCurrencyEnum["NGN"] = "NGN";
    ProductInputCurrencyEnum["NIO"] = "NIO";
    ProductInputCurrencyEnum["NOK"] = "NOK";
    ProductInputCurrencyEnum["NPR"] = "NPR";
    ProductInputCurrencyEnum["NZD"] = "NZD";
    ProductInputCurrencyEnum["OMR"] = "OMR";
    ProductInputCurrencyEnum["PAB"] = "PAB";
    ProductInputCurrencyEnum["PEN"] = "PEN";
    ProductInputCurrencyEnum["PGK"] = "PGK";
    ProductInputCurrencyEnum["PHP"] = "PHP";
    ProductInputCurrencyEnum["PKR"] = "PKR";
    ProductInputCurrencyEnum["PLN"] = "PLN";
    ProductInputCurrencyEnum["PYG"] = "PYG";
    ProductInputCurrencyEnum["QAR"] = "QAR";
    ProductInputCurrencyEnum["RON"] = "RON";
    ProductInputCurrencyEnum["RSD"] = "RSD";
    ProductInputCurrencyEnum["RUB"] = "RUB";
    ProductInputCurrencyEnum["RWF"] = "RWF";
    ProductInputCurrencyEnum["SAR"] = "SAR";
    ProductInputCurrencyEnum["SBD"] = "SBD";
    ProductInputCurrencyEnum["SCR"] = "SCR";
    ProductInputCurrencyEnum["SDG"] = "SDG";
    ProductInputCurrencyEnum["SEK"] = "SEK";
    ProductInputCurrencyEnum["SGD"] = "SGD";
    ProductInputCurrencyEnum["SHP"] = "SHP";
    ProductInputCurrencyEnum["SLE"] = "SLE";
    ProductInputCurrencyEnum["SLL"] = "SLL";
    ProductInputCurrencyEnum["SOS"] = "SOS";
    ProductInputCurrencyEnum["SRD"] = "SRD";
    ProductInputCurrencyEnum["SSP"] = "SSP";
    ProductInputCurrencyEnum["STN"] = "STN";
    ProductInputCurrencyEnum["SVC"] = "SVC";
    ProductInputCurrencyEnum["SYP"] = "SYP";
    ProductInputCurrencyEnum["SZL"] = "SZL";
    ProductInputCurrencyEnum["THB"] = "THB";
    ProductInputCurrencyEnum["TJS"] = "TJS";
    ProductInputCurrencyEnum["TMT"] = "TMT";
    ProductInputCurrencyEnum["TND"] = "TND";
    ProductInputCurrencyEnum["TOP"] = "TOP";
    ProductInputCurrencyEnum["TRY"] = "TRY";
    ProductInputCurrencyEnum["TTD"] = "TTD";
    ProductInputCurrencyEnum["TWD"] = "TWD";
    ProductInputCurrencyEnum["TZS"] = "TZS";
    ProductInputCurrencyEnum["UAH"] = "UAH";
    ProductInputCurrencyEnum["UGX"] = "UGX";
    ProductInputCurrencyEnum["USD"] = "USD";
    ProductInputCurrencyEnum["USN"] = "USN";
    ProductInputCurrencyEnum["UYI"] = "UYI";
    ProductInputCurrencyEnum["UYU"] = "UYU";
    ProductInputCurrencyEnum["UYW"] = "UYW";
    ProductInputCurrencyEnum["UZS"] = "UZS";
    ProductInputCurrencyEnum["VED"] = "VED";
    ProductInputCurrencyEnum["VES"] = "VES";
    ProductInputCurrencyEnum["VND"] = "VND";
    ProductInputCurrencyEnum["VUV"] = "VUV";
    ProductInputCurrencyEnum["WST"] = "WST";
    ProductInputCurrencyEnum["XAF"] = "XAF";
    ProductInputCurrencyEnum["XCD"] = "XCD";
    ProductInputCurrencyEnum["XOF"] = "XOF";
    ProductInputCurrencyEnum["XPF"] = "XPF";
    ProductInputCurrencyEnum["XSU"] = "XSU";
    ProductInputCurrencyEnum["XUA"] = "XUA";
    ProductInputCurrencyEnum["YER"] = "YER";
    ProductInputCurrencyEnum["ZAR"] = "ZAR";
    ProductInputCurrencyEnum["ZMW"] = "ZMW";
    ProductInputCurrencyEnum["ZWL"] = "ZWL";
})(ProductInputCurrencyEnum = exports.ProductInputCurrencyEnum || (exports.ProductInputCurrencyEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var ProspectStatus;
(function (ProspectStatus) {
    ProspectStatus["NEW"] = "NEW";
    ProspectStatus["GENERALENQUIRY"] = "GENERAL_ENQUIRY";
    ProspectStatus["SCHEDULEDCALLBACKWITHBOT"] = "SCHEDULED_CALLBACK_WITH_BOT";
    ProspectStatus["SCHEDULEDAPPOINTMENTWITHPERSON"] = "SCHEDULED_APPOINTMENT_WITH_PERSON";
    ProspectStatus["SCHEDULEDAPPOINTMENTFORSERVICE"] = "SCHEDULED_APPOINTMENT_FOR_SERVICE";
    ProspectStatus["NOTINTERESTED"] = "NOT_INTERESTED";
    ProspectStatus["PRODUCTORDERPLACED"] = "PRODUCT_ORDER_PLACED";
    ProspectStatus["SERVICEORDERPLACED"] = "SERVICE_ORDER_PLACED";
})(ProspectStatus = exports.ProspectStatus || (exports.ProspectStatus = {}));
/**
 *
 * @export
 * @enum {string}
 */
var Role;
(function (Role) {
    Role["ADMIN"] = "ADMIN";
    Role["READONLY"] = "READ_ONLY";
    Role["RESELLERADMIN"] = "RESELLER_ADMIN";
})(Role = exports.Role || (exports.Role = {}));
/**
 *
 * @export
 * @enum {string}
 */
var SortOrder;
(function (SortOrder) {
    SortOrder["Asc"] = "asc";
    SortOrder["Desc"] = "desc";
})(SortOrder = exports.SortOrder || (exports.SortOrder = {}));
/**
 *
 * @export
 * @enum {string}
 */
var Status;
(function (Status) {
    Status["Active"] = "active";
    Status["Inactive"] = "inactive";
})(Status = exports.Status || (exports.Status = {}));
/**
    * @export
    * @enum {string}
    */
var VoiceInputGenderEnum;
(function (VoiceInputGenderEnum) {
    VoiceInputGenderEnum["Male"] = "Male";
    VoiceInputGenderEnum["Female"] = "Female";
    VoiceInputGenderEnum["Neutral"] = "Neutral";
})(VoiceInputGenderEnum = exports.VoiceInputGenderEnum || (exports.VoiceInputGenderEnum = {}));
/**
    * @export
    * @enum {string}
    */
var VoiceOutputGenderEnum;
(function (VoiceOutputGenderEnum) {
    VoiceOutputGenderEnum["Male"] = "Male";
    VoiceOutputGenderEnum["Female"] = "Female";
    VoiceOutputGenderEnum["Neutral"] = "Neutral";
})(VoiceOutputGenderEnum = exports.VoiceOutputGenderEnum || (exports.VoiceOutputGenderEnum = {}));
/**
 * ActionAgentLinkApi - axios parameter creator
 * @export
 */
exports.ActionAgentLinkApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a Link Between an Action and an Agent
         * @summary Create a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionAgentLinkV1: (actionId, agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new base_1.RequiredError('actionId', 'Required parameter actionId was null or undefined when calling createActionAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling createActionAgentLinkV1.');
            }
            const localVarPath = `/v1/actions/{action_id}/ai-agents/{agent_id}/link`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Link Between an Action and an Agent
         * @summary Delete a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionAgentLinkV1: (actionId, agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new base_1.RequiredError('actionId', 'Required parameter actionId was null or undefined when calling deleteActionAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling deleteActionAgentLinkV1.');
            }
            const localVarPath = `/v1/actions/{action_id}/ai-agents/{agent_id}/link`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Actions Linked to a Specific Agent
         * @summary List All Actions Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsOfAgentV1: (agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling listActionsOfAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}/actions`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ActionAgentLinkApi - functional programming interface
 * @export
 */
exports.ActionAgentLinkApiFp = function (configuration) {
    return {
        /**
         * Create a Link Between an Action and an Agent
         * @summary Create a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionAgentLinkV1(actionId, agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ActionAgentLinkApiAxiosParamCreator(configuration).createActionAgentLinkV1(actionId, agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a Link Between an Action and an Agent
         * @summary Delete a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionAgentLinkV1(actionId, agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ActionAgentLinkApiAxiosParamCreator(configuration).deleteActionAgentLinkV1(actionId, agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List All Actions Linked to a Specific Agent
         * @summary List All Actions Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsOfAgentV1(agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ActionAgentLinkApiAxiosParamCreator(configuration).listActionsOfAgentV1(agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ActionAgentLinkApi - factory interface
 * @export
 */
exports.ActionAgentLinkApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Create a Link Between an Action and an Agent
         * @summary Create a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionAgentLinkV1(actionId, agentId, options) {
            return exports.ActionAgentLinkApiFp(configuration).createActionAgentLinkV1(actionId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Link Between an Action and an Agent
         * @summary Delete a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionAgentLinkV1(actionId, agentId, options) {
            return exports.ActionAgentLinkApiFp(configuration).deleteActionAgentLinkV1(actionId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Actions Linked to a Specific Agent
         * @summary List All Actions Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsOfAgentV1(agentId, options) {
            return exports.ActionAgentLinkApiFp(configuration).listActionsOfAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ActionAgentLinkApi - object-oriented interface
 * @export
 * @class ActionAgentLinkApi
 * @extends {BaseAPI}
 */
class ActionAgentLinkApi extends base_1.BaseAPI {
    /**
     * Create a Link Between an Action and an Agent
     * @summary Create a Link Between an Action and an Agent
     * @param {string} actionId ID of the action
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    createActionAgentLinkV1(actionId, agentId, options) {
        return exports.ActionAgentLinkApiFp(this.configuration).createActionAgentLinkV1(actionId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Link Between an Action and an Agent
     * @summary Delete a Link Between an Action and an Agent
     * @param {string} actionId ID of the action
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    deleteActionAgentLinkV1(actionId, agentId, options) {
        return exports.ActionAgentLinkApiFp(this.configuration).deleteActionAgentLinkV1(actionId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Actions Linked to a Specific Agent
     * @summary List All Actions Linked to a Specific Agent
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    listActionsOfAgentV1(agentId, options) {
        return exports.ActionAgentLinkApiFp(this.configuration).listActionsOfAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ActionAgentLinkApi = ActionAgentLinkApi;
/**
 * ActionsApi - axios parameter creator
 * @export
 */
exports.ActionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a New Action
         * @summary Create a New Action
         * @param {ActionInput} actionInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionV1: (actionInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'actionInput' is not null or undefined
            if (actionInput === null || actionInput === undefined) {
                throw new base_1.RequiredError('actionInput', 'Required parameter actionInput was null or undefined when calling createActionV1.');
            }
            const localVarPath = `/v1/actions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof actionInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(actionInput !== undefined ? actionInput : {}) : (actionInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Specific Action by ID
         * @summary Delete a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionV1: (actionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new base_1.RequiredError('actionId', 'Required parameter actionId was null or undefined when calling deleteActionV1.');
            }
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Specific Action by ID
         * @summary Get a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionV1: (actionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new base_1.RequiredError('actionId', 'Required parameter actionId was null or undefined when calling getActionV1.');
            }
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Actions
         * @summary List All Actions
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/actions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Specific Action by ID
         * @summary Update a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {ActionInput} actionInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActionV1: (actionId, actionInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new base_1.RequiredError('actionId', 'Required parameter actionId was null or undefined when calling updateActionV1.');
            }
            // verify required parameter 'actionInput' is not null or undefined
            if (actionInput === null || actionInput === undefined) {
                throw new base_1.RequiredError('actionInput', 'Required parameter actionInput was null or undefined when calling updateActionV1.');
            }
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof actionInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(actionInput !== undefined ? actionInput : {}) : (actionInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ActionsApi - functional programming interface
 * @export
 */
exports.ActionsApiFp = function (configuration) {
    return {
        /**
         * Create a New Action
         * @summary Create a New Action
         * @param {ActionInput} actionInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionV1(actionInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ActionsApiAxiosParamCreator(configuration).createActionV1(actionInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a Specific Action by ID
         * @summary Delete a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionV1(actionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ActionsApiAxiosParamCreator(configuration).deleteActionV1(actionId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a Specific Action by ID
         * @summary Get a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionV1(actionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ActionsApiAxiosParamCreator(configuration).getActionV1(actionId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List All Actions
         * @summary List All Actions
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ActionsApiAxiosParamCreator(configuration).listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a Specific Action by ID
         * @summary Update a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {ActionInput} actionInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActionV1(actionId, actionInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ActionsApiAxiosParamCreator(configuration).updateActionV1(actionId, actionInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ActionsApi - factory interface
 * @export
 */
exports.ActionsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Create a New Action
         * @summary Create a New Action
         * @param {ActionInput} actionInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionV1(actionInput, options) {
            return exports.ActionsApiFp(configuration).createActionV1(actionInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Action by ID
         * @summary Delete a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionV1(actionId, options) {
            return exports.ActionsApiFp(configuration).deleteActionV1(actionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Action by ID
         * @summary Get a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionV1(actionId, options) {
            return exports.ActionsApiFp(configuration).getActionV1(actionId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Actions
         * @summary List All Actions
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
            return exports.ActionsApiFp(configuration).listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Action by ID
         * @summary Update a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {ActionInput} actionInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActionV1(actionId, actionInput, options) {
            return exports.ActionsApiFp(configuration).updateActionV1(actionId, actionInput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
class ActionsApi extends base_1.BaseAPI {
    /**
     * Create a New Action
     * @summary Create a New Action
     * @param {ActionInput} actionInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    createActionV1(actionInput, options) {
        return exports.ActionsApiFp(this.configuration).createActionV1(actionInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Specific Action by ID
     * @summary Delete a Specific Action by ID
     * @param {string} actionId ID of the action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    deleteActionV1(actionId, options) {
        return exports.ActionsApiFp(this.configuration).deleteActionV1(actionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Specific Action by ID
     * @summary Get a Specific Action by ID
     * @param {string} actionId ID of the action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    getActionV1(actionId, options) {
        return exports.ActionsApiFp(this.configuration).getActionV1(actionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Actions
     * @summary List All Actions
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
        return exports.ActionsApiFp(this.configuration).listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Specific Action by ID
     * @summary Update a Specific Action by ID
     * @param {string} actionId ID of the action
     * @param {ActionInput} actionInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    updateActionV1(actionId, actionInput, options) {
        return exports.ActionsApiFp(this.configuration).updateActionV1(actionId, actionInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ActionsApi = ActionsApi;
/**
 * AgentsApi - axios parameter creator
 * @export
 */
exports.AgentsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a New AI Agent
         * @summary Create a New AI Agent
         * @param {AIAgentInput} aIAgentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAIAgentV1: (aIAgentInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'aIAgentInput' is not null or undefined
            if (aIAgentInput === null || aIAgentInput === undefined) {
                throw new base_1.RequiredError('aIAgentInput', 'Required parameter aIAgentInput was null or undefined when calling createAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof aIAgentInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(aIAgentInput !== undefined ? aIAgentInput : {}) : (aIAgentInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Specific AI Agent by ID
         * @summary Delete a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAIAgentV1: (agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling deleteAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Specific AI Agent by ID
         * @summary Get a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIAgentV1: (agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling getAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All AI Agents
         * @summary List All AI Agents
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIAgentsV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/ai-agents`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Specific AI Agent by ID
         * @summary Update a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {AIAgentInput} aIAgentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAIAgentV1: (agentId, aIAgentInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling updateAIAgentV1.');
            }
            // verify required parameter 'aIAgentInput' is not null or undefined
            if (aIAgentInput === null || aIAgentInput === undefined) {
                throw new base_1.RequiredError('aIAgentInput', 'Required parameter aIAgentInput was null or undefined when calling updateAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof aIAgentInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(aIAgentInput !== undefined ? aIAgentInput : {}) : (aIAgentInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * AgentsApi - functional programming interface
 * @export
 */
exports.AgentsApiFp = function (configuration) {
    return {
        /**
         * Create a New AI Agent
         * @summary Create a New AI Agent
         * @param {AIAgentInput} aIAgentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAIAgentV1(aIAgentInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentsApiAxiosParamCreator(configuration).createAIAgentV1(aIAgentInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a Specific AI Agent by ID
         * @summary Delete a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAIAgentV1(agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentsApiAxiosParamCreator(configuration).deleteAIAgentV1(agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a Specific AI Agent by ID
         * @summary Get a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIAgentV1(agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentsApiAxiosParamCreator(configuration).getAIAgentV1(agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List All AI Agents
         * @summary List All AI Agents
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIAgentsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentsApiAxiosParamCreator(configuration).listAIAgentsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a Specific AI Agent by ID
         * @summary Update a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {AIAgentInput} aIAgentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAIAgentV1(agentId, aIAgentInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentsApiAxiosParamCreator(configuration).updateAIAgentV1(agentId, aIAgentInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * AgentsApi - factory interface
 * @export
 */
exports.AgentsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Create a New AI Agent
         * @summary Create a New AI Agent
         * @param {AIAgentInput} aIAgentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAIAgentV1(aIAgentInput, options) {
            return exports.AgentsApiFp(configuration).createAIAgentV1(aIAgentInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific AI Agent by ID
         * @summary Delete a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAIAgentV1(agentId, options) {
            return exports.AgentsApiFp(configuration).deleteAIAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific AI Agent by ID
         * @summary Get a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIAgentV1(agentId, options) {
            return exports.AgentsApiFp(configuration).getAIAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All AI Agents
         * @summary List All AI Agents
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIAgentsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
            return exports.AgentsApiFp(configuration).listAIAgentsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific AI Agent by ID
         * @summary Update a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {AIAgentInput} aIAgentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAIAgentV1(agentId, aIAgentInput, options) {
            return exports.AgentsApiFp(configuration).updateAIAgentV1(agentId, aIAgentInput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AgentsApi - object-oriented interface
 * @export
 * @class AgentsApi
 * @extends {BaseAPI}
 */
class AgentsApi extends base_1.BaseAPI {
    /**
     * Create a New AI Agent
     * @summary Create a New AI Agent
     * @param {AIAgentInput} aIAgentInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    createAIAgentV1(aIAgentInput, options) {
        return exports.AgentsApiFp(this.configuration).createAIAgentV1(aIAgentInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Specific AI Agent by ID
     * @summary Delete a Specific AI Agent by ID
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    deleteAIAgentV1(agentId, options) {
        return exports.AgentsApiFp(this.configuration).deleteAIAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Specific AI Agent by ID
     * @summary Get a Specific AI Agent by ID
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    getAIAgentV1(agentId, options) {
        return exports.AgentsApiFp(this.configuration).getAIAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All AI Agents
     * @summary List All AI Agents
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    listAIAgentsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
        return exports.AgentsApiFp(this.configuration).listAIAgentsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Specific AI Agent by ID
     * @summary Update a Specific AI Agent by ID
     * @param {string} agentId ID of the agent
     * @param {AIAgentInput} aIAgentInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    updateAIAgentV1(agentId, aIAgentInput, options) {
        return exports.AgentsApiFp(this.configuration).updateAIAgentV1(agentId, aIAgentInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AgentsApi = AgentsApi;
/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
exports.AnalyticsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get fine grained analytics data from Trata AI like call, duration stats, etc.
         * @summary Get Metrics
         * @param {BatchMetricsRequests} batchMetricsRequests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1MetricsPost: (batchMetricsRequests, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'batchMetricsRequests' is not null or undefined
            if (batchMetricsRequests === null || batchMetricsRequests === undefined) {
                throw new base_1.RequiredError('batchMetricsRequests', 'Required parameter batchMetricsRequests was null or undefined when calling getMetricsV1MetricsPost.');
            }
            const localVarPath = `/v1/metrics`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof batchMetricsRequests !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(batchMetricsRequests !== undefined ? batchMetricsRequests : {}) : (batchMetricsRequests || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get aggregated stats from Trata AI like call count, prospect count, etc.
         * @summary Get Aggregated Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallStatsV1StatsGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/stats`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * AnalyticsApi - functional programming interface
 * @export
 */
exports.AnalyticsApiFp = function (configuration) {
    return {
        /**
         * Get fine grained analytics data from Trata AI like call, duration stats, etc.
         * @summary Get Metrics
         * @param {BatchMetricsRequests} batchMetricsRequests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1MetricsPost(batchMetricsRequests, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AnalyticsApiAxiosParamCreator(configuration).getMetricsV1MetricsPost(batchMetricsRequests, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get aggregated stats from Trata AI like call count, prospect count, etc.
         * @summary Get Aggregated Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallStatsV1StatsGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AnalyticsApiAxiosParamCreator(configuration).getOverallStatsV1StatsGet(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * AnalyticsApi - factory interface
 * @export
 */
exports.AnalyticsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Get fine grained analytics data from Trata AI like call, duration stats, etc.
         * @summary Get Metrics
         * @param {BatchMetricsRequests} batchMetricsRequests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1MetricsPost(batchMetricsRequests, options) {
            return exports.AnalyticsApiFp(configuration).getMetricsV1MetricsPost(batchMetricsRequests, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregated stats from Trata AI like call count, prospect count, etc.
         * @summary Get Aggregated Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallStatsV1StatsGet(options) {
            return exports.AnalyticsApiFp(configuration).getOverallStatsV1StatsGet(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
class AnalyticsApi extends base_1.BaseAPI {
    /**
     * Get fine grained analytics data from Trata AI like call, duration stats, etc.
     * @summary Get Metrics
     * @param {BatchMetricsRequests} batchMetricsRequests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    getMetricsV1MetricsPost(batchMetricsRequests, options) {
        return exports.AnalyticsApiFp(this.configuration).getMetricsV1MetricsPost(batchMetricsRequests, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get aggregated stats from Trata AI like call count, prospect count, etc.
     * @summary Get Aggregated Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    getOverallStatsV1StatsGet(options) {
        return exports.AnalyticsApiFp(this.configuration).getOverallStatsV1StatsGet(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AnalyticsApi = AnalyticsApi;
/**
 * ApiKeyApi - axios parameter creator
 * @export
 */
exports.ApiKeyApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create Api Key
         * @param {ApiKeyRequest} apiKeyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyV1: (apiKeyRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'apiKeyRequest' is not null or undefined
            if (apiKeyRequest === null || apiKeyRequest === undefined) {
                throw new base_1.RequiredError('apiKeyRequest', 'Required parameter apiKeyRequest was null or undefined when calling createApiKeyV1.');
            }
            const localVarPath = `/v1/api-keys`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof apiKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(apiKeyRequest !== undefined ? apiKeyRequest : {}) : (apiKeyRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete Api Key
         * @param {string} keyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyV1: (keyId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'keyId' is not null or undefined
            if (keyId === null || keyId === undefined) {
                throw new base_1.RequiredError('keyId', 'Required parameter keyId was null or undefined when calling deleteApiKeyV1.');
            }
            const localVarPath = `/v1/api-keys/{key_id}`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Call Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallKeyV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/api-keys/call-key`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/api-keys`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ApiKeyApi - functional programming interface
 * @export
 */
exports.ApiKeyApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Create Api Key
         * @param {ApiKeyRequest} apiKeyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyV1(apiKeyRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ApiKeyApiAxiosParamCreator(configuration).createApiKeyV1(apiKeyRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Delete Api Key
         * @param {string} keyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyV1(keyId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ApiKeyApiAxiosParamCreator(configuration).deleteApiKeyV1(keyId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get Call Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallKeyV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ApiKeyApiAxiosParamCreator(configuration).getCallKeyV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ApiKeyApiAxiosParamCreator(configuration).listApiKeysV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ApiKeyApi - factory interface
 * @export
 */
exports.ApiKeyApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Create Api Key
         * @param {ApiKeyRequest} apiKeyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyV1(apiKeyRequest, options) {
            return exports.ApiKeyApiFp(configuration).createApiKeyV1(apiKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete Api Key
         * @param {string} keyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyV1(keyId, options) {
            return exports.ApiKeyApiFp(configuration).deleteApiKeyV1(keyId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Call Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallKeyV1(options) {
            return exports.ApiKeyApiFp(configuration).getCallKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysV1(options) {
            return exports.ApiKeyApiFp(configuration).listApiKeysV1(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ApiKeyApi - object-oriented interface
 * @export
 * @class ApiKeyApi
 * @extends {BaseAPI}
 */
class ApiKeyApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create Api Key
     * @param {ApiKeyRequest} apiKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    createApiKeyV1(apiKeyRequest, options) {
        return exports.ApiKeyApiFp(this.configuration).createApiKeyV1(apiKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete Api Key
     * @param {string} keyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    deleteApiKeyV1(keyId, options) {
        return exports.ApiKeyApiFp(this.configuration).deleteApiKeyV1(keyId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Call Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    getCallKeyV1(options) {
        return exports.ApiKeyApiFp(this.configuration).getCallKeyV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Api Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    listApiKeysV1(options) {
        return exports.ApiKeyApiFp(this.configuration).listApiKeysV1(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ApiKeyApi = ApiKeyApi;
/**
 * BillingApi - axios parameter creator
 * @export
 */
exports.BillingApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create Checkout Session For Billable Product
         * @param {string} billableProductId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForBillableProductV1: (billableProductId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'billableProductId' is not null or undefined
            if (billableProductId === null || billableProductId === undefined) {
                throw new base_1.RequiredError('billableProductId', 'Required parameter billableProductId was null or undefined when calling createCheckoutSessionForBillableProductV1.');
            }
            const localVarPath = `/v1/subscription/billable-products/{billable_product_id}/checkout`
                .replace(`{${"billable_product_id"}}`, encodeURIComponent(String(billableProductId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Customer Session Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerSessionSecretV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/subscription/customer-session-secret`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Subscription Billable Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionBillableProductsV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/subscription/billable-products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Subscription Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPortalV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/subscription/portal`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/subscription`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * BillingApi - functional programming interface
 * @export
 */
exports.BillingApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Create Checkout Session For Billable Product
         * @param {string} billableProductId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForBillableProductV1(billableProductId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BillingApiAxiosParamCreator(configuration).createCheckoutSessionForBillableProductV1(billableProductId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get Customer Session Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerSessionSecretV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BillingApiAxiosParamCreator(configuration).getCustomerSessionSecretV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get Subscription Billable Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionBillableProductsV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BillingApiAxiosParamCreator(configuration).getSubscriptionBillableProductsV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get Subscription Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPortalV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BillingApiAxiosParamCreator(configuration).getSubscriptionPortalV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BillingApiAxiosParamCreator(configuration).getSubscriptionV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * BillingApi - factory interface
 * @export
 */
exports.BillingApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Create Checkout Session For Billable Product
         * @param {string} billableProductId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForBillableProductV1(billableProductId, options) {
            return exports.BillingApiFp(configuration).createCheckoutSessionForBillableProductV1(billableProductId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Customer Session Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerSessionSecretV1(options) {
            return exports.BillingApiFp(configuration).getCustomerSessionSecretV1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Subscription Billable Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionBillableProductsV1(options) {
            return exports.BillingApiFp(configuration).getSubscriptionBillableProductsV1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Subscription Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPortalV1(options) {
            return exports.BillingApiFp(configuration).getSubscriptionPortalV1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionV1(options) {
            return exports.BillingApiFp(configuration).getSubscriptionV1(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
class BillingApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create Checkout Session For Billable Product
     * @param {string} billableProductId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    createCheckoutSessionForBillableProductV1(billableProductId, options) {
        return exports.BillingApiFp(this.configuration).createCheckoutSessionForBillableProductV1(billableProductId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Customer Session Secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getCustomerSessionSecretV1(options) {
        return exports.BillingApiFp(this.configuration).getCustomerSessionSecretV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Subscription Billable Products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getSubscriptionBillableProductsV1(options) {
        return exports.BillingApiFp(this.configuration).getSubscriptionBillableProductsV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Subscription Portal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getSubscriptionPortalV1(options) {
        return exports.BillingApiFp(this.configuration).getSubscriptionPortalV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getSubscriptionV1(options) {
        return exports.BillingApiFp(this.configuration).getSubscriptionV1(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BillingApi = BillingApi;
/**
 * ConversationProspectLinkApi - axios parameter creator
 * @export
 */
exports.ConversationProspectLinkApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a link between a conversation and a prospect
         * @summary Create a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationProspectLinkV1: (conversationId, prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new base_1.RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling createConversationProspectLinkV1.');
            }
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new base_1.RequiredError('prospectId', 'Required parameter prospectId was null or undefined when calling createConversationProspectLinkV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}/prospects/{prospect_id}/links`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a link between a conversation and a prospect
         * @summary Delete a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationProspectLinkV1: (conversationId, prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new base_1.RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling deleteConversationProspectLinkV1.');
            }
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new base_1.RequiredError('prospectId', 'Required parameter prospectId was null or undefined when calling deleteConversationProspectLinkV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}/prospects/{prospect_id}/links`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all conversations linked to a specific prospect
         * @summary List all conversations linked to a specific prospect
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsOfProspectsV1: (prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new base_1.RequiredError('prospectId', 'Required parameter prospectId was null or undefined when calling listConversationsOfProspectsV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}/conversations`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ConversationProspectLinkApi - functional programming interface
 * @export
 */
exports.ConversationProspectLinkApiFp = function (configuration) {
    return {
        /**
         * Create a link between a conversation and a prospect
         * @summary Create a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationProspectLinkV1(conversationId, prospectId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ConversationProspectLinkApiAxiosParamCreator(configuration).createConversationProspectLinkV1(conversationId, prospectId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a link between a conversation and a prospect
         * @summary Delete a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationProspectLinkV1(conversationId, prospectId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ConversationProspectLinkApiAxiosParamCreator(configuration).deleteConversationProspectLinkV1(conversationId, prospectId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List all conversations linked to a specific prospect
         * @summary List all conversations linked to a specific prospect
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsOfProspectsV1(prospectId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ConversationProspectLinkApiAxiosParamCreator(configuration).listConversationsOfProspectsV1(prospectId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ConversationProspectLinkApi - factory interface
 * @export
 */
exports.ConversationProspectLinkApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Create a link between a conversation and a prospect
         * @summary Create a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationProspectLinkV1(conversationId, prospectId, options) {
            return exports.ConversationProspectLinkApiFp(configuration).createConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a link between a conversation and a prospect
         * @summary Delete a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationProspectLinkV1(conversationId, prospectId, options) {
            return exports.ConversationProspectLinkApiFp(configuration).deleteConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all conversations linked to a specific prospect
         * @summary List all conversations linked to a specific prospect
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsOfProspectsV1(prospectId, options) {
            return exports.ConversationProspectLinkApiFp(configuration).listConversationsOfProspectsV1(prospectId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ConversationProspectLinkApi - object-oriented interface
 * @export
 * @class ConversationProspectLinkApi
 * @extends {BaseAPI}
 */
class ConversationProspectLinkApi extends base_1.BaseAPI {
    /**
     * Create a link between a conversation and a prospect
     * @summary Create a link between a conversation and a prospect
     * @param {string} conversationId ID of the conversation
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    createConversationProspectLinkV1(conversationId, prospectId, options) {
        return exports.ConversationProspectLinkApiFp(this.configuration).createConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a link between a conversation and a prospect
     * @summary Delete a link between a conversation and a prospect
     * @param {string} conversationId ID of the conversation
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    deleteConversationProspectLinkV1(conversationId, prospectId, options) {
        return exports.ConversationProspectLinkApiFp(this.configuration).deleteConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all conversations linked to a specific prospect
     * @summary List all conversations linked to a specific prospect
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    listConversationsOfProspectsV1(prospectId, options) {
        return exports.ConversationProspectLinkApiFp(this.configuration).listConversationsOfProspectsV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ConversationProspectLinkApi = ConversationProspectLinkApi;
/**
 * ConversationsApi - axios parameter creator
 * @export
 */
exports.ConversationsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add Feedback to a Specific Conversation
         * @summary Add Feedback to a Specific Conversation
         * @param {string} conversationId ID of the conversation
         * @param {Comment} comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedbackV1: (conversationId, comment, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new base_1.RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling addFeedbackV1.');
            }
            // verify required parameter 'comment' is not null or undefined
            if (comment === null || comment === undefined) {
                throw new base_1.RequiredError('comment', 'Required parameter comment was null or undefined when calling addFeedbackV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}/feedback`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof comment !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(comment !== undefined ? comment : {}) : (comment || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a New Conversation
         * @summary Create a New Conversation
         * @param {ConversationInput} conversationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationV1: (conversationInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conversationInput' is not null or undefined
            if (conversationInput === null || conversationInput === undefined) {
                throw new base_1.RequiredError('conversationInput', 'Required parameter conversationInput was null or undefined when calling createConversationV1.');
            }
            const localVarPath = `/v1/conversations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof conversationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(conversationInput !== undefined ? conversationInput : {}) : (conversationInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Specific Conversation by ID
         * @summary Delete a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationV1: (conversationId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new base_1.RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling deleteConversationV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Specific Conversation by ID
         * @summary Get a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationV1: (conversationId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new base_1.RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling getConversationV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Conversations
         * @summary List All Conversations
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/conversations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Specific Conversation by ID
         * @summary Update a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {ConversationInput} conversationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationV1: (conversationId, conversationInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new base_1.RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling updateConversationV1.');
            }
            // verify required parameter 'conversationInput' is not null or undefined
            if (conversationInput === null || conversationInput === undefined) {
                throw new base_1.RequiredError('conversationInput', 'Required parameter conversationInput was null or undefined when calling updateConversationV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof conversationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(conversationInput !== undefined ? conversationInput : {}) : (conversationInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ConversationsApi - functional programming interface
 * @export
 */
exports.ConversationsApiFp = function (configuration) {
    return {
        /**
         * Add Feedback to a Specific Conversation
         * @summary Add Feedback to a Specific Conversation
         * @param {string} conversationId ID of the conversation
         * @param {Comment} comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedbackV1(conversationId, comment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ConversationsApiAxiosParamCreator(configuration).addFeedbackV1(conversationId, comment, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a New Conversation
         * @summary Create a New Conversation
         * @param {ConversationInput} conversationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationV1(conversationInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ConversationsApiAxiosParamCreator(configuration).createConversationV1(conversationInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a Specific Conversation by ID
         * @summary Delete a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationV1(conversationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ConversationsApiAxiosParamCreator(configuration).deleteConversationV1(conversationId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a Specific Conversation by ID
         * @summary Get a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationV1(conversationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ConversationsApiAxiosParamCreator(configuration).getConversationV1(conversationId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List All Conversations
         * @summary List All Conversations
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ConversationsApiAxiosParamCreator(configuration).listConversationsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a Specific Conversation by ID
         * @summary Update a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {ConversationInput} conversationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationV1(conversationId, conversationInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ConversationsApiAxiosParamCreator(configuration).updateConversationV1(conversationId, conversationInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ConversationsApi - factory interface
 * @export
 */
exports.ConversationsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Add Feedback to a Specific Conversation
         * @summary Add Feedback to a Specific Conversation
         * @param {string} conversationId ID of the conversation
         * @param {Comment} comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedbackV1(conversationId, comment, options) {
            return exports.ConversationsApiFp(configuration).addFeedbackV1(conversationId, comment, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a New Conversation
         * @summary Create a New Conversation
         * @param {ConversationInput} conversationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationV1(conversationInput, options) {
            return exports.ConversationsApiFp(configuration).createConversationV1(conversationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Conversation by ID
         * @summary Delete a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationV1(conversationId, options) {
            return exports.ConversationsApiFp(configuration).deleteConversationV1(conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Conversation by ID
         * @summary Get a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationV1(conversationId, options) {
            return exports.ConversationsApiFp(configuration).getConversationV1(conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Conversations
         * @summary List All Conversations
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
            return exports.ConversationsApiFp(configuration).listConversationsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Conversation by ID
         * @summary Update a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {ConversationInput} conversationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationV1(conversationId, conversationInput, options) {
            return exports.ConversationsApiFp(configuration).updateConversationV1(conversationId, conversationInput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ConversationsApi - object-oriented interface
 * @export
 * @class ConversationsApi
 * @extends {BaseAPI}
 */
class ConversationsApi extends base_1.BaseAPI {
    /**
     * Add Feedback to a Specific Conversation
     * @summary Add Feedback to a Specific Conversation
     * @param {string} conversationId ID of the conversation
     * @param {Comment} comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    addFeedbackV1(conversationId, comment, options) {
        return exports.ConversationsApiFp(this.configuration).addFeedbackV1(conversationId, comment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a New Conversation
     * @summary Create a New Conversation
     * @param {ConversationInput} conversationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    createConversationV1(conversationInput, options) {
        return exports.ConversationsApiFp(this.configuration).createConversationV1(conversationInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Specific Conversation by ID
     * @summary Delete a Specific Conversation by ID
     * @param {string} conversationId ID of the conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    deleteConversationV1(conversationId, options) {
        return exports.ConversationsApiFp(this.configuration).deleteConversationV1(conversationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Specific Conversation by ID
     * @summary Get a Specific Conversation by ID
     * @param {string} conversationId ID of the conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    getConversationV1(conversationId, options) {
        return exports.ConversationsApiFp(this.configuration).getConversationV1(conversationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Conversations
     * @summary List All Conversations
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    listConversationsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
        return exports.ConversationsApiFp(this.configuration).listConversationsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Specific Conversation by ID
     * @summary Update a Specific Conversation by ID
     * @param {string} conversationId ID of the conversation
     * @param {ConversationInput} conversationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    updateConversationV1(conversationId, conversationInput, options) {
        return exports.ConversationsApiFp(this.configuration).updateConversationV1(conversationId, conversationInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ConversationsApi = ConversationsApi;
/**
 * DataPlaneApi - axios parameter creator
 * @export
 */
exports.DataPlaneApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new connection for an AI Agent to start a voice conversation
         * @summary Create Connection
         * @param {string} agentId
         * @param {ConnectionSource} connectionSource
         * @param {string} [prospectId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection: (agentId, connectionSource, prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling createConnection.');
            }
            // verify required parameter 'connectionSource' is not null or undefined
            if (connectionSource === null || connectionSource === undefined) {
                throw new base_1.RequiredError('connectionSource', 'Required parameter connectionSource was null or undefined when calling createConnection.');
            }
            const localVarPath = `/v1/connections`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (agentId !== undefined) {
                localVarQueryParameter['agentId'] = agentId;
            }
            if (prospectId !== undefined) {
                localVarQueryParameter['prospect_id'] = prospectId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof connectionSource !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(connectionSource !== undefined ? connectionSource : {}) : (connectionSource || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get the audio stream xml for Plivo to start a voice conversation
         * @summary Get Audio Stream XML For Plivo
         * @param {string} connectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlivoAudioStreamXml: (connectionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'connectionId' is not null or undefined
            if (connectionId === null || connectionId === undefined) {
                throw new base_1.RequiredError('connectionId', 'Required parameter connectionId was null or undefined when calling getPlivoAudioStreamXml.');
            }
            const localVarPath = `/v1/connections/{connection_id}/plivo-audio-stream-xml`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DataPlaneApi - functional programming interface
 * @export
 */
exports.DataPlaneApiFp = function (configuration) {
    return {
        /**
         * Create a new connection for an AI Agent to start a voice conversation
         * @summary Create Connection
         * @param {string} agentId
         * @param {ConnectionSource} connectionSource
         * @param {string} [prospectId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(agentId, connectionSource, prospectId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DataPlaneApiAxiosParamCreator(configuration).createConnection(agentId, connectionSource, prospectId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get the audio stream xml for Plivo to start a voice conversation
         * @summary Get Audio Stream XML For Plivo
         * @param {string} connectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlivoAudioStreamXml(connectionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DataPlaneApiAxiosParamCreator(configuration).getPlivoAudioStreamXml(connectionId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * DataPlaneApi - factory interface
 * @export
 */
exports.DataPlaneApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Create a new connection for an AI Agent to start a voice conversation
         * @summary Create Connection
         * @param {string} agentId
         * @param {ConnectionSource} connectionSource
         * @param {string} [prospectId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(agentId, connectionSource, prospectId, options) {
            return exports.DataPlaneApiFp(configuration).createConnection(agentId, connectionSource, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the audio stream xml for Plivo to start a voice conversation
         * @summary Get Audio Stream XML For Plivo
         * @param {string} connectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlivoAudioStreamXml(connectionId, options) {
            return exports.DataPlaneApiFp(configuration).getPlivoAudioStreamXml(connectionId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DataPlaneApi - object-oriented interface
 * @export
 * @class DataPlaneApi
 * @extends {BaseAPI}
 */
class DataPlaneApi extends base_1.BaseAPI {
    /**
     * Create a new connection for an AI Agent to start a voice conversation
     * @summary Create Connection
     * @param {string} agentId
     * @param {ConnectionSource} connectionSource
     * @param {string} [prospectId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPlaneApi
     */
    createConnection(agentId, connectionSource, prospectId, options) {
        return exports.DataPlaneApiFp(this.configuration).createConnection(agentId, connectionSource, prospectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the audio stream xml for Plivo to start a voice conversation
     * @summary Get Audio Stream XML For Plivo
     * @param {string} connectionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPlaneApi
     */
    getPlivoAudioStreamXml(connectionId, options) {
        return exports.DataPlaneApiFp(this.configuration).getPlivoAudioStreamXml(connectionId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DataPlaneApi = DataPlaneApi;
/**
 * FilesApi - axios parameter creator
 * @export
 */
exports.FilesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete files from Trata account
         * @summary Delete Files
         * @param {string} fileIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1: (fileIds, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'fileIds' is not null or undefined
            if (fileIds === null || fileIds === undefined) {
                throw new base_1.RequiredError('fileIds', 'Required parameter fileIds was null or undefined when calling deleteFileV1.');
            }
            const localVarPath = `/v1/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (fileIds !== undefined) {
                localVarQueryParameter['file_ids'] = fileIds;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete files from Trata reseller account
         * @summary Delete Files
         * @param {string} fileIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerFilesV1: (fileIds, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'fileIds' is not null or undefined
            if (fileIds === null || fileIds === undefined) {
                throw new base_1.RequiredError('fileIds', 'Required parameter fileIds was null or undefined when calling deleteResellerFilesV1.');
            }
            const localVarPath = `/v1/resellers/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (fileIds !== undefined) {
                localVarQueryParameter['file_ids'] = fileIds;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1: (files, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'files' is not null or undefined
            if (files === null || files === undefined) {
                throw new base_1.RequiredError('files', 'Required parameter files was null or undefined when calling uploadFileV1.');
            }
            const localVarPath = `/v1/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (files) {
                localVarFormParams.append('files', files.join(base_1.COLLECTION_FORMATS.csv));
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadResellerFilesV1: (files, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'files' is not null or undefined
            if (files === null || files === undefined) {
                throw new base_1.RequiredError('files', 'Required parameter files was null or undefined when calling uploadResellerFilesV1.');
            }
            const localVarPath = `/v1/resellers/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (files) {
                localVarFormParams.append('files', files.join(base_1.COLLECTION_FORMATS.csv));
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * FilesApi - functional programming interface
 * @export
 */
exports.FilesApiFp = function (configuration) {
    return {
        /**
         * Delete files from Trata account
         * @summary Delete Files
         * @param {string} fileIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1(fileIds, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.FilesApiAxiosParamCreator(configuration).deleteFileV1(fileIds, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete files from Trata reseller account
         * @summary Delete Files
         * @param {string} fileIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerFilesV1(fileIds, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.FilesApiAxiosParamCreator(configuration).deleteResellerFilesV1(fileIds, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1(files, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.FilesApiAxiosParamCreator(configuration).uploadFileV1(files, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadResellerFilesV1(files, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.FilesApiAxiosParamCreator(configuration).uploadResellerFilesV1(files, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * FilesApi - factory interface
 * @export
 */
exports.FilesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Delete files from Trata account
         * @summary Delete Files
         * @param {string} fileIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1(fileIds, options) {
            return exports.FilesApiFp(configuration).deleteFileV1(fileIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete files from Trata reseller account
         * @summary Delete Files
         * @param {string} fileIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerFilesV1(fileIds, options) {
            return exports.FilesApiFp(configuration).deleteResellerFilesV1(fileIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1(files, options) {
            return exports.FilesApiFp(configuration).uploadFileV1(files, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload file to Trata account to use in AI Agents
         * @summary Upload Files
         * @param {Array<any>} files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadResellerFilesV1(files, options) {
            return exports.FilesApiFp(configuration).uploadResellerFilesV1(files, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
class FilesApi extends base_1.BaseAPI {
    /**
     * Delete files from Trata account
     * @summary Delete Files
     * @param {string} fileIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    deleteFileV1(fileIds, options) {
        return exports.FilesApiFp(this.configuration).deleteFileV1(fileIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete files from Trata reseller account
     * @summary Delete Files
     * @param {string} fileIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    deleteResellerFilesV1(fileIds, options) {
        return exports.FilesApiFp(this.configuration).deleteResellerFilesV1(fileIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload file to Trata account to use in AI Agents
     * @summary Upload Files
     * @param {Array<any>} files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    uploadFileV1(files, options) {
        return exports.FilesApiFp(this.configuration).uploadFileV1(files, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload file to Trata account to use in AI Agents
     * @summary Upload Files
     * @param {Array<any>} files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    uploadResellerFilesV1(files, options) {
        return exports.FilesApiFp(this.configuration).uploadResellerFilesV1(files, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FilesApi = FilesApi;
/**
 * HealthApi - axios parameter creator
 * @export
 */
exports.HealthApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Heart Beat check to check the health of Trata Backend
         * @summary Heart Beat Status Of Trata Backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStatusGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * HealthApi - functional programming interface
 * @export
 */
exports.HealthApiFp = function (configuration) {
    return {
        /**
         * Heart Beat check to check the health of Trata Backend
         * @summary Heart Beat Status Of Trata Backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStatusGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.HealthApiAxiosParamCreator(configuration).statusStatusGet(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * HealthApi - factory interface
 * @export
 */
exports.HealthApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Heart Beat check to check the health of Trata Backend
         * @summary Heart Beat Status Of Trata Backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStatusGet(options) {
            return exports.HealthApiFp(configuration).statusStatusGet(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
class HealthApi extends base_1.BaseAPI {
    /**
     * Heart Beat check to check the health of Trata Backend
     * @summary Heart Beat Status Of Trata Backend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    statusStatusGet(options) {
        return exports.HealthApiFp(this.configuration).statusStatusGet(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.HealthApi = HealthApi;
/**
 * HiveApi - axios parameter creator
 * @export
 */
exports.HiveApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
         * @summary Create a New Hive
         * @param {HiveContentInput} hiveContentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveV1: (hiveContentInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hiveContentInput' is not null or undefined
            if (hiveContentInput === null || hiveContentInput === undefined) {
                throw new base_1.RequiredError('hiveContentInput', 'Required parameter hiveContentInput was null or undefined when calling createHiveV1.');
            }
            const localVarPath = `/v1/hives`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof hiveContentInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(hiveContentInput !== undefined ? hiveContentInput : {}) : (hiveContentInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Specific Hive by ID
         * @summary Delete a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveV1: (hiveId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new base_1.RequiredError('hiveId', 'Required parameter hiveId was null or undefined when calling deleteHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Specific Hive by ID
         * @summary Get a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHiveV1: (hiveId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new base_1.RequiredError('hiveId', 'Required parameter hiveId was null or undefined when calling getHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Hives
         * @summary List All Hives
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/hives`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Specific Hive by ID
         * @summary Update a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {HiveContentOutput} hiveContentOutput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHiveV1: (hiveId, hiveContentOutput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new base_1.RequiredError('hiveId', 'Required parameter hiveId was null or undefined when calling updateHiveV1.');
            }
            // verify required parameter 'hiveContentOutput' is not null or undefined
            if (hiveContentOutput === null || hiveContentOutput === undefined) {
                throw new base_1.RequiredError('hiveContentOutput', 'Required parameter hiveContentOutput was null or undefined when calling updateHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof hiveContentOutput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(hiveContentOutput !== undefined ? hiveContentOutput : {}) : (hiveContentOutput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * HiveApi - functional programming interface
 * @export
 */
exports.HiveApiFp = function (configuration) {
    return {
        /**
         * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
         * @summary Create a New Hive
         * @param {HiveContentInput} hiveContentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveV1(hiveContentInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.HiveApiAxiosParamCreator(configuration).createHiveV1(hiveContentInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a Specific Hive by ID
         * @summary Delete a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveV1(hiveId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.HiveApiAxiosParamCreator(configuration).deleteHiveV1(hiveId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a Specific Hive by ID
         * @summary Get a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHiveV1(hiveId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.HiveApiAxiosParamCreator(configuration).getHiveV1(hiveId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List All Hives
         * @summary List All Hives
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.HiveApiAxiosParamCreator(configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a Specific Hive by ID
         * @summary Update a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {HiveContentOutput} hiveContentOutput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHiveV1(hiveId, hiveContentOutput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.HiveApiAxiosParamCreator(configuration).updateHiveV1(hiveId, hiveContentOutput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * HiveApi - factory interface
 * @export
 */
exports.HiveApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
         * @summary Create a New Hive
         * @param {HiveContentInput} hiveContentInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveV1(hiveContentInput, options) {
            return exports.HiveApiFp(configuration).createHiveV1(hiveContentInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Hive by ID
         * @summary Delete a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveV1(hiveId, options) {
            return exports.HiveApiFp(configuration).deleteHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Hive by ID
         * @summary Get a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHiveV1(hiveId, options) {
            return exports.HiveApiFp(configuration).getHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Hives
         * @summary List All Hives
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
            return exports.HiveApiFp(configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Hive by ID
         * @summary Update a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {HiveContentOutput} hiveContentOutput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHiveV1(hiveId, hiveContentOutput, options) {
            return exports.HiveApiFp(configuration).updateHiveV1(hiveId, hiveContentOutput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * HiveApi - object-oriented interface
 * @export
 * @class HiveApi
 * @extends {BaseAPI}
 */
class HiveApi extends base_1.BaseAPI {
    /**
     * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
     * @summary Create a New Hive
     * @param {HiveContentInput} hiveContentInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    createHiveV1(hiveContentInput, options) {
        return exports.HiveApiFp(this.configuration).createHiveV1(hiveContentInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Specific Hive by ID
     * @summary Delete a Specific Hive by ID
     * @param {string} hiveId ID of the hive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    deleteHiveV1(hiveId, options) {
        return exports.HiveApiFp(this.configuration).deleteHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Specific Hive by ID
     * @summary Get a Specific Hive by ID
     * @param {string} hiveId ID of the hive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    getHiveV1(hiveId, options) {
        return exports.HiveApiFp(this.configuration).getHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Hives
     * @summary List All Hives
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
        return exports.HiveApiFp(this.configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Specific Hive by ID
     * @summary Update a Specific Hive by ID
     * @param {string} hiveId ID of the hive
     * @param {HiveContentOutput} hiveContentOutput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    updateHiveV1(hiveId, hiveContentOutput, options) {
        return exports.HiveApiFp(this.configuration).updateHiveV1(hiveId, hiveContentOutput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.HiveApi = HiveApi;
/**
 * HiveAgentLinkApi - axios parameter creator
 * @export
 */
exports.HiveAgentLinkApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a Link Between a Hive and an Agent
         * @summary Create a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveAgentLinkV1: (hiveId, agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new base_1.RequiredError('hiveId', 'Required parameter hiveId was null or undefined when calling createHiveAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling createHiveAgentLinkV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}/ai-agents/{agent_id}/link`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Link Between a Hive and an Agent
         * @summary Delete a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveAgentLinkV1: (hiveId, agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new base_1.RequiredError('hiveId', 'Required parameter hiveId was null or undefined when calling deleteHiveAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling deleteHiveAgentLinkV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}/ai-agents/{agent_id}/link`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Agents Linked to a Specific Hive
         * @summary List All Agents Linked to a Specific Hive
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfHiveV1: (hiveId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new base_1.RequiredError('hiveId', 'Required parameter hiveId was null or undefined when calling listAgentsOfHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}/ai-agents`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Hives Linked to a Specific Agent
         * @summary List All Hives Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesOfAgentV1: (agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling listHivesOfAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}/hives`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * HiveAgentLinkApi - functional programming interface
 * @export
 */
exports.HiveAgentLinkApiFp = function (configuration) {
    return {
        /**
         * Create a Link Between a Hive and an Agent
         * @summary Create a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveAgentLinkV1(hiveId, agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.HiveAgentLinkApiAxiosParamCreator(configuration).createHiveAgentLinkV1(hiveId, agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a Link Between a Hive and an Agent
         * @summary Delete a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveAgentLinkV1(hiveId, agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.HiveAgentLinkApiAxiosParamCreator(configuration).deleteHiveAgentLinkV1(hiveId, agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List All Agents Linked to a Specific Hive
         * @summary List All Agents Linked to a Specific Hive
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfHiveV1(hiveId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.HiveAgentLinkApiAxiosParamCreator(configuration).listAgentsOfHiveV1(hiveId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List All Hives Linked to a Specific Agent
         * @summary List All Hives Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesOfAgentV1(agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.HiveAgentLinkApiAxiosParamCreator(configuration).listHivesOfAgentV1(agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * HiveAgentLinkApi - factory interface
 * @export
 */
exports.HiveAgentLinkApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Create a Link Between a Hive and an Agent
         * @summary Create a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveAgentLinkV1(hiveId, agentId, options) {
            return exports.HiveAgentLinkApiFp(configuration).createHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Link Between a Hive and an Agent
         * @summary Delete a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveAgentLinkV1(hiveId, agentId, options) {
            return exports.HiveAgentLinkApiFp(configuration).deleteHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Agents Linked to a Specific Hive
         * @summary List All Agents Linked to a Specific Hive
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfHiveV1(hiveId, options) {
            return exports.HiveAgentLinkApiFp(configuration).listAgentsOfHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Hives Linked to a Specific Agent
         * @summary List All Hives Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesOfAgentV1(agentId, options) {
            return exports.HiveAgentLinkApiFp(configuration).listHivesOfAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * HiveAgentLinkApi - object-oriented interface
 * @export
 * @class HiveAgentLinkApi
 * @extends {BaseAPI}
 */
class HiveAgentLinkApi extends base_1.BaseAPI {
    /**
     * Create a Link Between a Hive and an Agent
     * @summary Create a Link Between a Hive and an Agent
     * @param {string} hiveId ID of the hive
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    createHiveAgentLinkV1(hiveId, agentId, options) {
        return exports.HiveAgentLinkApiFp(this.configuration).createHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Link Between a Hive and an Agent
     * @summary Delete a Link Between a Hive and an Agent
     * @param {string} hiveId ID of the hive
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    deleteHiveAgentLinkV1(hiveId, agentId, options) {
        return exports.HiveAgentLinkApiFp(this.configuration).deleteHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Agents Linked to a Specific Hive
     * @summary List All Agents Linked to a Specific Hive
     * @param {string} hiveId ID of the hive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    listAgentsOfHiveV1(hiveId, options) {
        return exports.HiveAgentLinkApiFp(this.configuration).listAgentsOfHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Hives Linked to a Specific Agent
     * @summary List All Hives Linked to a Specific Agent
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    listHivesOfAgentV1(agentId, options) {
        return exports.HiveAgentLinkApiFp(this.configuration).listHivesOfAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.HiveAgentLinkApi = HiveAgentLinkApi;
/**
 * InternalApi - axios parameter creator
 * @export
 */
exports.InternalApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {AcceptInviteRequest} acceptInviteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInviteV1: (acceptInviteRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'acceptInviteRequest' is not null or undefined
            if (acceptInviteRequest === null || acceptInviteRequest === undefined) {
                throw new base_1.RequiredError('acceptInviteRequest', 'Required parameter acceptInviteRequest was null or undefined when calling acceptInviteV1.');
            }
            const localVarPath = `/v1/invites/accept`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof acceptInviteRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(acceptInviteRequest !== undefined ? acceptInviteRequest : {}) : (acceptInviteRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationV1: (bodyCreateOrganizationV1, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'bodyCreateOrganizationV1' is not null or undefined
            if (bodyCreateOrganizationV1 === null || bodyCreateOrganizationV1 === undefined) {
                throw new base_1.RequiredError('bodyCreateOrganizationV1', 'Required parameter bodyCreateOrganizationV1 was null or undefined when calling createOrganizationV1.');
            }
            const localVarPath = `/v1/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof bodyCreateOrganizationV1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(bodyCreateOrganizationV1 !== undefined ? bodyCreateOrganizationV1 : {}) : (bodyCreateOrganizationV1 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1: (userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling deleteUserV1.');
            }
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/invites`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInviteV1: (guestInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'guestInput' is not null or undefined
            if (guestInput === null || guestInput === undefined) {
                throw new base_1.RequiredError('guestInput', 'Required parameter guestInput was null or undefined when calling sendInviteV1.');
            }
            const localVarPath = `/v1/invites`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof guestInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(guestInput !== undefined ? guestInput : {}) : (guestInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Updateorganization
         * @param {string} orgId ID of the organization
         * @param {OrganizationInput} organizationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationV1: (orgId, organizationInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'orgId' is not null or undefined
            if (orgId === null || orgId === undefined) {
                throw new base_1.RequiredError('orgId', 'Required parameter orgId was null or undefined when calling updateOrganizationV1.');
            }
            // verify required parameter 'organizationInput' is not null or undefined
            if (organizationInput === null || organizationInput === undefined) {
                throw new base_1.RequiredError('organizationInput', 'Required parameter organizationInput was null or undefined when calling updateOrganizationV1.');
            }
            const localVarPath = `/v1/organizations/{org_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof organizationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(organizationInput !== undefined ? organizationInput : {}) : (organizationInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId
         * @param {UpdateUserPayload} updateUserPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserV1: (userId, updateUserPayload, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling updateUserV1.');
            }
            // verify required parameter 'updateUserPayload' is not null or undefined
            if (updateUserPayload === null || updateUserPayload === undefined) {
                throw new base_1.RequiredError('updateUserPayload', 'Required parameter updateUserPayload was null or undefined when calling updateUserV1.');
            }
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof updateUserPayload !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(updateUserPayload !== undefined ? updateUserPayload : {}) : (updateUserPayload || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * InternalApi - functional programming interface
 * @export
 */
exports.InternalApiFp = function (configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {AcceptInviteRequest} acceptInviteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInviteV1(acceptInviteRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).acceptInviteV1(acceptInviteRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationV1(bodyCreateOrganizationV1, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).createOrganizationV1(bodyCreateOrganizationV1, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).deleteOrganizationV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1(userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).deleteUserV1(userId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).getOrganizationV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).listUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInviteV1(guestInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).sendInviteV1(guestInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Updateorganization
         * @param {string} orgId ID of the organization
         * @param {OrganizationInput} organizationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationV1(orgId, organizationInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).updateOrganizationV1(orgId, organizationInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId
         * @param {UpdateUserPayload} updateUserPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserV1(userId, updateUserPayload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InternalApiAxiosParamCreator(configuration).updateUserV1(userId, updateUserPayload, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * InternalApi - factory interface
 * @export
 */
exports.InternalApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {AcceptInviteRequest} acceptInviteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInviteV1(acceptInviteRequest, options) {
            return exports.InternalApiFp(configuration).acceptInviteV1(acceptInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationV1(bodyCreateOrganizationV1, options) {
            return exports.InternalApiFp(configuration).createOrganizationV1(bodyCreateOrganizationV1, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationV1(options) {
            return exports.InternalApiFp(configuration).deleteOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1(userId, options) {
            return exports.InternalApiFp(configuration).deleteUserV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationV1(options) {
            return exports.InternalApiFp(configuration).getOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
            return exports.InternalApiFp(configuration).listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
            return exports.InternalApiFp(configuration).listUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInviteV1(guestInput, options) {
            return exports.InternalApiFp(configuration).sendInviteV1(guestInput, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updateorganization
         * @param {string} orgId ID of the organization
         * @param {OrganizationInput} organizationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationV1(orgId, organizationInput, options) {
            return exports.InternalApiFp(configuration).updateOrganizationV1(orgId, organizationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId
         * @param {UpdateUserPayload} updateUserPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserV1(userId, updateUserPayload, options) {
            return exports.InternalApiFp(configuration).updateUserV1(userId, updateUserPayload, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
class InternalApi extends base_1.BaseAPI {
    /**
     * Accept invite and add new user to organization
     * @summary Acceptinvite
     * @param {AcceptInviteRequest} acceptInviteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    acceptInviteV1(acceptInviteRequest, options) {
        return exports.InternalApiFp(this.configuration).acceptInviteV1(acceptInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new organization and adds the user as the \"ADMIN\" user for the org
     * @summary Createorganization
     * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    createOrganizationV1(bodyCreateOrganizationV1, options) {
        return exports.InternalApiFp(this.configuration).createOrganizationV1(bodyCreateOrganizationV1, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deleteorganization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    deleteOrganizationV1(options) {
        return exports.InternalApiFp(this.configuration).deleteOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a user
     * @summary Deleteuser
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    deleteUserV1(userId, options) {
        return exports.InternalApiFp(this.configuration).deleteUserV1(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Getorganization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    getOrganizationV1(options) {
        return exports.InternalApiFp(this.configuration).getOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List of all open invites from the organization
     * @summary Listinvites
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
        return exports.InternalApiFp(this.configuration).listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all users under the user\'s organization
     * @summary Listusers
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    listUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
        return exports.InternalApiFp(this.configuration).listUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Invite a new user to an organization or resend invite to the user if the user is already invited
     * @summary Inviteusers
     * @param {GuestInput} guestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    sendInviteV1(guestInput, options) {
        return exports.InternalApiFp(this.configuration).sendInviteV1(guestInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updateorganization
     * @param {string} orgId ID of the organization
     * @param {OrganizationInput} organizationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    updateOrganizationV1(orgId, organizationInput, options) {
        return exports.InternalApiFp(this.configuration).updateOrganizationV1(orgId, organizationInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update user details
     * @summary Updateuser
     * @param {string} userId
     * @param {UpdateUserPayload} updateUserPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    updateUserV1(userId, updateUserPayload, options) {
        return exports.InternalApiFp(this.configuration).updateUserV1(userId, updateUserPayload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.InternalApi = InternalApi;
/**
 * ProductsApi - axios parameter creator
 * @export
 */
exports.ProductsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a New Product
         * @summary Create a New Product
         * @param {ProductInput} productInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductV1: (productInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productInput' is not null or undefined
            if (productInput === null || productInput === undefined) {
                throw new base_1.RequiredError('productInput', 'Required parameter productInput was null or undefined when calling createProductV1.');
            }
            const localVarPath = `/v1/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof productInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(productInput !== undefined ? productInput : {}) : (productInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Specific Product by ID
         * @summary Delete a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductV1: (productId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling deleteProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Specific Product by ID
         * @summary Get a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductV1: (productId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling getProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Agents Linked to a Specific Product
         * @summary List All Agents Linked to a Specific Product
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfProductV1: (productId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling listAgentsOfProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}/agents`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Products
         * @summary List All Products
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {Array<string>} [tags] Filter products by specific tags
         * @param {Array<string>} [productIds] Filter by specific product IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }
            if (productIds) {
                localVarQueryParameter['product_ids'] = productIds;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Specific Product by ID
         * @summary Update a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {ProductInput} productInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductV1: (productId, productInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling updateProductV1.');
            }
            // verify required parameter 'productInput' is not null or undefined
            if (productInput === null || productInput === undefined) {
                throw new base_1.RequiredError('productInput', 'Required parameter productInput was null or undefined when calling updateProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof productInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(productInput !== undefined ? productInput : {}) : (productInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ProductsApi - functional programming interface
 * @export
 */
exports.ProductsApiFp = function (configuration) {
    return {
        /**
         * Create a New Product
         * @summary Create a New Product
         * @param {ProductInput} productInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductV1(productInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).createProductV1(productInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a Specific Product by ID
         * @summary Delete a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductV1(productId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).deleteProductV1(productId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a Specific Product by ID
         * @summary Get a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductV1(productId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).getProductV1(productId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List All Agents Linked to a Specific Product
         * @summary List All Agents Linked to a Specific Product
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfProductV1(productId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).listAgentsOfProductV1(productId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List All Products
         * @summary List All Products
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {Array<string>} [tags] Filter products by specific tags
         * @param {Array<string>} [productIds] Filter by specific product IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a Specific Product by ID
         * @summary Update a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {ProductInput} productInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductV1(productId, productInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).updateProductV1(productId, productInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ProductsApi - factory interface
 * @export
 */
exports.ProductsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Create a New Product
         * @summary Create a New Product
         * @param {ProductInput} productInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductV1(productInput, options) {
            return exports.ProductsApiFp(configuration).createProductV1(productInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Product by ID
         * @summary Delete a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductV1(productId, options) {
            return exports.ProductsApiFp(configuration).deleteProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Product by ID
         * @summary Get a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductV1(productId, options) {
            return exports.ProductsApiFp(configuration).getProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Agents Linked to a Specific Product
         * @summary List All Agents Linked to a Specific Product
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfProductV1(productId, options) {
            return exports.ProductsApiFp(configuration).listAgentsOfProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Products
         * @summary List All Products
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {Array<string>} [tags] Filter products by specific tags
         * @param {Array<string>} [productIds] Filter by specific product IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options) {
            return exports.ProductsApiFp(configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Product by ID
         * @summary Update a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {ProductInput} productInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductV1(productId, productInput, options) {
            return exports.ProductsApiFp(configuration).updateProductV1(productId, productInput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
class ProductsApi extends base_1.BaseAPI {
    /**
     * Create a New Product
     * @summary Create a New Product
     * @param {ProductInput} productInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    createProductV1(productInput, options) {
        return exports.ProductsApiFp(this.configuration).createProductV1(productInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Specific Product by ID
     * @summary Delete a Specific Product by ID
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    deleteProductV1(productId, options) {
        return exports.ProductsApiFp(this.configuration).deleteProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Specific Product by ID
     * @summary Get a Specific Product by ID
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getProductV1(productId, options) {
        return exports.ProductsApiFp(this.configuration).getProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Agents Linked to a Specific Product
     * @summary List All Agents Linked to a Specific Product
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    listAgentsOfProductV1(productId, options) {
        return exports.ProductsApiFp(this.configuration).listAgentsOfProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Products
     * @summary List All Products
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {Array<string>} [tags] Filter products by specific tags
     * @param {Array<string>} [productIds] Filter by specific product IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options) {
        return exports.ProductsApiFp(this.configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Specific Product by ID
     * @summary Update a Specific Product by ID
     * @param {string} productId ID of the product
     * @param {ProductInput} productInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    updateProductV1(productId, productInput, options) {
        return exports.ProductsApiFp(this.configuration).updateProductV1(productId, productInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProductsApi = ProductsApi;
/**
 * ProspectsApi - axios parameter creator
 * @export
 */
exports.ProspectsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a New Prospect
         * @summary Create a New Prospect
         * @param {ProspectInput} prospectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProspectV1: (prospectInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectInput' is not null or undefined
            if (prospectInput === null || prospectInput === undefined) {
                throw new base_1.RequiredError('prospectInput', 'Required parameter prospectInput was null or undefined when calling createProspectV1.');
            }
            const localVarPath = `/v1/prospects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof prospectInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(prospectInput !== undefined ? prospectInput : {}) : (prospectInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a Specific Prospect by ID
         * @summary Delete a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProspectV1: (prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new base_1.RequiredError('prospectId', 'Required parameter prospectId was null or undefined when calling deleteProspectV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Specific Prospect by ID
         * @summary Get a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProspectV1: (prospectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new base_1.RequiredError('prospectId', 'Required parameter prospectId was null or undefined when calling getProspectV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List All Prospects
         * @summary List All Prospects
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProspectsV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/prospects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Specific Prospect by ID
         * @summary Update a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {ProspectInput} prospectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProspectV1: (prospectId, prospectInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new base_1.RequiredError('prospectId', 'Required parameter prospectId was null or undefined when calling updateProspectV1.');
            }
            // verify required parameter 'prospectInput' is not null or undefined
            if (prospectInput === null || prospectInput === undefined) {
                throw new base_1.RequiredError('prospectInput', 'Required parameter prospectInput was null or undefined when calling updateProspectV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof prospectInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(prospectInput !== undefined ? prospectInput : {}) : (prospectInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ProspectsApi - functional programming interface
 * @export
 */
exports.ProspectsApiFp = function (configuration) {
    return {
        /**
         * Create a New Prospect
         * @summary Create a New Prospect
         * @param {ProspectInput} prospectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProspectV1(prospectInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProspectsApiAxiosParamCreator(configuration).createProspectV1(prospectInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a Specific Prospect by ID
         * @summary Delete a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProspectV1(prospectId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProspectsApiAxiosParamCreator(configuration).deleteProspectV1(prospectId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a Specific Prospect by ID
         * @summary Get a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProspectV1(prospectId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProspectsApiAxiosParamCreator(configuration).getProspectV1(prospectId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List All Prospects
         * @summary List All Prospects
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProspectsApiAxiosParamCreator(configuration).listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a Specific Prospect by ID
         * @summary Update a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {ProspectInput} prospectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProspectV1(prospectId, prospectInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProspectsApiAxiosParamCreator(configuration).updateProspectV1(prospectId, prospectInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ProspectsApi - factory interface
 * @export
 */
exports.ProspectsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Create a New Prospect
         * @summary Create a New Prospect
         * @param {ProspectInput} prospectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProspectV1(prospectInput, options) {
            return exports.ProspectsApiFp(configuration).createProspectV1(prospectInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Prospect by ID
         * @summary Delete a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProspectV1(prospectId, options) {
            return exports.ProspectsApiFp(configuration).deleteProspectV1(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Prospect by ID
         * @summary Get a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProspectV1(prospectId, options) {
            return exports.ProspectsApiFp(configuration).getProspectV1(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Prospects
         * @summary List All Prospects
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
            return exports.ProspectsApiFp(configuration).listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Prospect by ID
         * @summary Update a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {ProspectInput} prospectInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProspectV1(prospectId, prospectInput, options) {
            return exports.ProspectsApiFp(configuration).updateProspectV1(prospectId, prospectInput, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ProspectsApi - object-oriented interface
 * @export
 * @class ProspectsApi
 * @extends {BaseAPI}
 */
class ProspectsApi extends base_1.BaseAPI {
    /**
     * Create a New Prospect
     * @summary Create a New Prospect
     * @param {ProspectInput} prospectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    createProspectV1(prospectInput, options) {
        return exports.ProspectsApiFp(this.configuration).createProspectV1(prospectInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Specific Prospect by ID
     * @summary Delete a Specific Prospect by ID
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    deleteProspectV1(prospectId, options) {
        return exports.ProspectsApiFp(this.configuration).deleteProspectV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Specific Prospect by ID
     * @summary Get a Specific Prospect by ID
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    getProspectV1(prospectId, options) {
        return exports.ProspectsApiFp(this.configuration).getProspectV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List All Prospects
     * @summary List All Prospects
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
        return exports.ProspectsApiFp(this.configuration).listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Specific Prospect by ID
     * @summary Update a Specific Prospect by ID
     * @param {string} prospectId ID of the prospect
     * @param {ProspectInput} prospectInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    updateProspectV1(prospectId, prospectInput, options) {
        return exports.ProspectsApiFp(this.configuration).updateProspectV1(prospectId, prospectInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProspectsApi = ProspectsApi;
/**
 * ResellerApi - axios parameter creator
 * @export
 */
exports.ResellerApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Accept Invite
         * @param {AcceptInviteRequest} acceptInviteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptResellerUserInviteV1: (acceptInviteRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'acceptInviteRequest' is not null or undefined
            if (acceptInviteRequest === null || acceptInviteRequest === undefined) {
                throw new base_1.RequiredError('acceptInviteRequest', 'Required parameter acceptInviteRequest was null or undefined when calling acceptResellerUserInviteV1.');
            }
            const localVarPath = `/v1/resellers/invites/accept`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof acceptInviteRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(acceptInviteRequest !== undefined ? acceptInviteRequest : {}) : (acceptInviteRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Add customer credit
         * @summary Add Customer Credit
         * @param {string} customerOrgId
         * @param {Array<CustomerCreditRequest>} customerCreditRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCustomerCreditV1: (customerOrgId, customerCreditRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling addCustomerCreditV1.');
            }
            // verify required parameter 'customerCreditRequest' is not null or undefined
            if (customerCreditRequest === null || customerCreditRequest === undefined) {
                throw new base_1.RequiredError('customerCreditRequest', 'Required parameter customerCreditRequest was null or undefined when calling addCustomerCreditV1.');
            }
            const localVarPath = `/v1/resellers/customer/{customer_org_id}/credits`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof customerCreditRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(customerCreditRequest !== undefined ? customerCreditRequest : {}) : (customerCreditRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Add Reseller settings
         * @summary Organization Settings
         * @param {OrganizationSettings} organizationSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResellerSettingsV1: (organizationSettings, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organizationSettings' is not null or undefined
            if (organizationSettings === null || organizationSettings === undefined) {
                throw new base_1.RequiredError('organizationSettings', 'Required parameter organizationSettings was null or undefined when calling addResellerSettingsV1.');
            }
            const localVarPath = `/v1/resellers/settings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof organizationSettings !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(organizationSettings !== undefined ? organizationSettings : {}) : (organizationSettings || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new customer organization under a reseller organization
         * @summary Create Customer
         * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerOrganizationV1: (bodyCreateCustomerOrganizationV1, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'bodyCreateCustomerOrganizationV1' is not null or undefined
            if (bodyCreateCustomerOrganizationV1 === null || bodyCreateCustomerOrganizationV1 === undefined) {
                throw new base_1.RequiredError('bodyCreateCustomerOrganizationV1', 'Required parameter bodyCreateCustomerOrganizationV1 was null or undefined when calling createCustomerOrganizationV1.');
            }
            const localVarPath = `/v1/resellers/customers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof bodyCreateCustomerOrganizationV1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(bodyCreateCustomerOrganizationV1 !== undefined ? bodyCreateCustomerOrganizationV1 : {}) : (bodyCreateCustomerOrganizationV1 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
         * @summary Create Reseller Organization
         * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResellerOrganizationV1: (bodyCreateResellerOrganizationV1, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'bodyCreateResellerOrganizationV1' is not null or undefined
            if (bodyCreateResellerOrganizationV1 === null || bodyCreateResellerOrganizationV1 === undefined) {
                throw new base_1.RequiredError('bodyCreateResellerOrganizationV1', 'Required parameter bodyCreateResellerOrganizationV1 was null or undefined when calling createResellerOrganizationV1.');
            }
            const localVarPath = `/v1/resellers/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof bodyCreateResellerOrganizationV1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(bodyCreateResellerOrganizationV1 !== undefined ? bodyCreateResellerOrganizationV1 : {}) : (bodyCreateResellerOrganizationV1 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a user
         * @summary Delete Reseller User
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerUserV1: (userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling deleteResellerUserV1.');
            }
            const localVarPath = `/v1/resellers/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
         * @summary Get Customer Credentials
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCredentialsV1: (customerOrgId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling getCustomerCredentialsV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/credentials`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get customer credits
         * @summary Get Customer Credits
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCreditsV1: (customerOrgId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling getCustomerCreditsV1.');
            }
            const localVarPath = `/v1/resellers/customer/{customer_org_id}/credits`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a customer organization by id under a reseller organization
         * @summary Get Customer Org
         * @param {string} customerOrgId
         * @param {boolean} [includeUsers]
         * @param {boolean} [includeResellerAdminCredentials]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerOrganizationV1: (customerOrgId, includeUsers, includeResellerAdminCredentials, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling getCustomerOrganizationV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (includeUsers !== undefined) {
                localVarQueryParameter['include_users'] = includeUsers;
            }
            if (includeResellerAdminCredentials !== undefined) {
                localVarQueryParameter['include_reseller_admin_credentials'] = includeResellerAdminCredentials;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get organization settings
         * @summary Get Organization Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSettingsV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/settings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get analytics data for Reseller
         * @summary Get Reseller Metrics
         * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerMetricsV1: (resellerBatchMetricsRequests, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'resellerBatchMetricsRequests' is not null or undefined
            if (resellerBatchMetricsRequests === null || resellerBatchMetricsRequests === undefined) {
                throw new base_1.RequiredError('resellerBatchMetricsRequests', 'Required parameter resellerBatchMetricsRequests was null or undefined when calling getResellerMetricsV1.');
            }
            const localVarPath = `/v1/resellers/metrics`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof resellerBatchMetricsRequests !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(resellerBatchMetricsRequests !== undefined ? resellerBatchMetricsRequests : {}) : (resellerBatchMetricsRequests || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a reseller organization by id
         * @summary Get Reseller Organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerOrganizationV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get reseller pricing for customer
         * @summary Get Reseller Pricing
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerPricingV1: (customerOrgId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling getResellerPricingV1.');
            }
            const localVarPath = `/v1/resellers/customer/{customer_org_id}/pricing`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the customer organizations under a reseller organization
         * @summary List Customers
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomerOrganizationsV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/customers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List of all open invites from the organization
         * @summary List Reseller User Invites
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUserInvitesV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/invites`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all users under the user\'s organization
         * @summary List Reseller Users
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUsersV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Invite Users
         * @param {GuestInput} guestInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendResellerUserInviteV1: (guestInput, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'guestInput' is not null or undefined
            if (guestInput === null || guestInput === undefined) {
                throw new base_1.RequiredError('guestInput', 'Required parameter guestInput was null or undefined when calling sendResellerUserInviteV1.');
            }
            const localVarPath = `/v1/resellers/invites`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof guestInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(guestInput !== undefined ? guestInput : {}) : (guestInput || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sync reseller stripe customer
         * @summary Stripe Sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeSyncV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/resellers/settings/stripe-sync`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update customer pricing
         * @summary Reseller Customer Pricing Update
         * @param {string} customerOrgId
         * @param {Array<PriceUpdateRequest>} priceUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerPricingV1: (customerOrgId, priceUpdateRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new base_1.RequiredError('customerOrgId', 'Required parameter customerOrgId was null or undefined when calling updateCustomerPricingV1.');
            }
            // verify required parameter 'priceUpdateRequest' is not null or undefined
            if (priceUpdateRequest === null || priceUpdateRequest === undefined) {
                throw new base_1.RequiredError('priceUpdateRequest', 'Required parameter priceUpdateRequest was null or undefined when calling updateCustomerPricingV1.');
            }
            const localVarPath = `/v1/resellers/customer/{customer_org_id}/pricing`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof priceUpdateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(priceUpdateRequest !== undefined ? priceUpdateRequest : {}) : (priceUpdateRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a reseller organization
         * @summary Update Reseller Organization
         * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerOrganizationV1: (updateResellerOrganizationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'updateResellerOrganizationRequest' is not null or undefined
            if (updateResellerOrganizationRequest === null || updateResellerOrganizationRequest === undefined) {
                throw new base_1.RequiredError('updateResellerOrganizationRequest', 'Required parameter updateResellerOrganizationRequest was null or undefined when calling updateResellerOrganizationV1.');
            }
            const localVarPath = `/v1/resellers/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof updateResellerOrganizationRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(updateResellerOrganizationRequest !== undefined ? updateResellerOrganizationRequest : {}) : (updateResellerOrganizationRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update organization settings
         * @summary Organization Settings Update
         * @param {OrganizationSettings} organizationSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerSettingsV1: (organizationSettings, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organizationSettings' is not null or undefined
            if (organizationSettings === null || organizationSettings === undefined) {
                throw new base_1.RequiredError('organizationSettings', 'Required parameter organizationSettings was null or undefined when calling updateResellerSettingsV1.');
            }
            const localVarPath = `/v1/resellers/settings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof organizationSettings !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(organizationSettings !== undefined ? organizationSettings : {}) : (organizationSettings || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update user details
         * @summary Update Reseller User
         * @param {string} userId
         * @param {UpdateUserPayload} updateUserPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerUserV1: (userId, updateUserPayload, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling updateResellerUserV1.');
            }
            // verify required parameter 'updateUserPayload' is not null or undefined
            if (updateUserPayload === null || updateUserPayload === undefined) {
                throw new base_1.RequiredError('updateUserPayload', 'Required parameter updateUserPayload was null or undefined when calling updateResellerUserV1.');
            }
            const localVarPath = `/v1/resellers/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof updateUserPayload !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(updateUserPayload !== undefined ? updateUserPayload : {}) : (updateUserPayload || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ResellerApi - functional programming interface
 * @export
 */
exports.ResellerApiFp = function (configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Accept Invite
         * @param {AcceptInviteRequest} acceptInviteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptResellerUserInviteV1(acceptInviteRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).acceptResellerUserInviteV1(acceptInviteRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Add customer credit
         * @summary Add Customer Credit
         * @param {string} customerOrgId
         * @param {Array<CustomerCreditRequest>} customerCreditRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCustomerCreditV1(customerOrgId, customerCreditRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).addCustomerCreditV1(customerOrgId, customerCreditRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Add Reseller settings
         * @summary Organization Settings
         * @param {OrganizationSettings} organizationSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResellerSettingsV1(organizationSettings, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).addResellerSettingsV1(organizationSettings, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Creates a new customer organization under a reseller organization
         * @summary Create Customer
         * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
         * @summary Create Reseller Organization
         * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete a user
         * @summary Delete Reseller User
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerUserV1(userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).deleteResellerUserV1(userId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
         * @summary Get Customer Credentials
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCredentialsV1(customerOrgId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).getCustomerCredentialsV1(customerOrgId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get customer credits
         * @summary Get Customer Credits
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCreditsV1(customerOrgId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).getCustomerCreditsV1(customerOrgId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a customer organization by id under a reseller organization
         * @summary Get Customer Org
         * @param {string} customerOrgId
         * @param {boolean} [includeUsers]
         * @param {boolean} [includeResellerAdminCredentials]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerOrganizationV1(customerOrgId, includeUsers, includeResellerAdminCredentials, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).getCustomerOrganizationV1(customerOrgId, includeUsers, includeResellerAdminCredentials, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get organization settings
         * @summary Get Organization Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSettingsV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).getOrganizationSettingsV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get analytics data for Reseller
         * @summary Get Reseller Metrics
         * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerMetricsV1(resellerBatchMetricsRequests, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).getResellerMetricsV1(resellerBatchMetricsRequests, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a reseller organization by id
         * @summary Get Reseller Organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerOrganizationV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).getResellerOrganizationV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get reseller pricing for customer
         * @summary Get Reseller Pricing
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerPricingV1(customerOrgId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).getResellerPricingV1(customerOrgId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Lists all the customer organizations under a reseller organization
         * @summary List Customers
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomerOrganizationsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).listCustomerOrganizationsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * List of all open invites from the organization
         * @summary List Reseller User Invites
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Lists all users under the user\'s organization
         * @summary List Reseller Users
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Invite Users
         * @param {GuestInput} guestInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendResellerUserInviteV1(guestInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).sendResellerUserInviteV1(guestInput, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Sync reseller stripe customer
         * @summary Stripe Sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeSyncV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).stripeSyncV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update customer pricing
         * @summary Reseller Customer Pricing Update
         * @param {string} customerOrgId
         * @param {Array<PriceUpdateRequest>} priceUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerPricingV1(customerOrgId, priceUpdateRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).updateCustomerPricingV1(customerOrgId, priceUpdateRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a reseller organization
         * @summary Update Reseller Organization
         * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerOrganizationV1(updateResellerOrganizationRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).updateResellerOrganizationV1(updateResellerOrganizationRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update organization settings
         * @summary Organization Settings Update
         * @param {OrganizationSettings} organizationSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerSettingsV1(organizationSettings, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).updateResellerSettingsV1(organizationSettings, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update user details
         * @summary Update Reseller User
         * @param {string} userId
         * @param {UpdateUserPayload} updateUserPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerUserV1(userId, updateUserPayload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ResellerApiAxiosParamCreator(configuration).updateResellerUserV1(userId, updateUserPayload, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ResellerApi - factory interface
 * @export
 */
exports.ResellerApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Accept Invite
         * @param {AcceptInviteRequest} acceptInviteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptResellerUserInviteV1(acceptInviteRequest, options) {
            return exports.ResellerApiFp(configuration).acceptResellerUserInviteV1(acceptInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add customer credit
         * @summary Add Customer Credit
         * @param {string} customerOrgId
         * @param {Array<CustomerCreditRequest>} customerCreditRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCustomerCreditV1(customerOrgId, customerCreditRequest, options) {
            return exports.ResellerApiFp(configuration).addCustomerCreditV1(customerOrgId, customerCreditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add Reseller settings
         * @summary Organization Settings
         * @param {OrganizationSettings} organizationSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResellerSettingsV1(organizationSettings, options) {
            return exports.ResellerApiFp(configuration).addResellerSettingsV1(organizationSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new customer organization under a reseller organization
         * @summary Create Customer
         * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options) {
            return exports.ResellerApiFp(configuration).createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
         * @summary Create Reseller Organization
         * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options) {
            return exports.ResellerApiFp(configuration).createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user
         * @summary Delete Reseller User
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerUserV1(userId, options) {
            return exports.ResellerApiFp(configuration).deleteResellerUserV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
         * @summary Get Customer Credentials
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCredentialsV1(customerOrgId, options) {
            return exports.ResellerApiFp(configuration).getCustomerCredentialsV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get customer credits
         * @summary Get Customer Credits
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCreditsV1(customerOrgId, options) {
            return exports.ResellerApiFp(configuration).getCustomerCreditsV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a customer organization by id under a reseller organization
         * @summary Get Customer Org
         * @param {string} customerOrgId
         * @param {boolean} [includeUsers]
         * @param {boolean} [includeResellerAdminCredentials]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerOrganizationV1(customerOrgId, includeUsers, includeResellerAdminCredentials, options) {
            return exports.ResellerApiFp(configuration).getCustomerOrganizationV1(customerOrgId, includeUsers, includeResellerAdminCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization settings
         * @summary Get Organization Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSettingsV1(options) {
            return exports.ResellerApiFp(configuration).getOrganizationSettingsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get analytics data for Reseller
         * @summary Get Reseller Metrics
         * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerMetricsV1(resellerBatchMetricsRequests, options) {
            return exports.ResellerApiFp(configuration).getResellerMetricsV1(resellerBatchMetricsRequests, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a reseller organization by id
         * @summary Get Reseller Organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerOrganizationV1(options) {
            return exports.ResellerApiFp(configuration).getResellerOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get reseller pricing for customer
         * @summary Get Reseller Pricing
         * @param {string} customerOrgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerPricingV1(customerOrgId, options) {
            return exports.ResellerApiFp(configuration).getResellerPricingV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the customer organizations under a reseller organization
         * @summary List Customers
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomerOrganizationsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
            return exports.ResellerApiFp(configuration).listCustomerOrganizationsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * List of all open invites from the organization
         * @summary List Reseller User Invites
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
            return exports.ResellerApiFp(configuration).listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all users under the user\'s organization
         * @summary List Reseller Users
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
            return exports.ResellerApiFp(configuration).listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Invite Users
         * @param {GuestInput} guestInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendResellerUserInviteV1(guestInput, options) {
            return exports.ResellerApiFp(configuration).sendResellerUserInviteV1(guestInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync reseller stripe customer
         * @summary Stripe Sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeSyncV1(options) {
            return exports.ResellerApiFp(configuration).stripeSyncV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Update customer pricing
         * @summary Reseller Customer Pricing Update
         * @param {string} customerOrgId
         * @param {Array<PriceUpdateRequest>} priceUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerPricingV1(customerOrgId, priceUpdateRequest, options) {
            return exports.ResellerApiFp(configuration).updateCustomerPricingV1(customerOrgId, priceUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a reseller organization
         * @summary Update Reseller Organization
         * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerOrganizationV1(updateResellerOrganizationRequest, options) {
            return exports.ResellerApiFp(configuration).updateResellerOrganizationV1(updateResellerOrganizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update organization settings
         * @summary Organization Settings Update
         * @param {OrganizationSettings} organizationSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerSettingsV1(organizationSettings, options) {
            return exports.ResellerApiFp(configuration).updateResellerSettingsV1(organizationSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user details
         * @summary Update Reseller User
         * @param {string} userId
         * @param {UpdateUserPayload} updateUserPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerUserV1(userId, updateUserPayload, options) {
            return exports.ResellerApiFp(configuration).updateResellerUserV1(userId, updateUserPayload, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ResellerApi - object-oriented interface
 * @export
 * @class ResellerApi
 * @extends {BaseAPI}
 */
class ResellerApi extends base_1.BaseAPI {
    /**
     * Accept invite and add new user to organization
     * @summary Accept Invite
     * @param {AcceptInviteRequest} acceptInviteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    acceptResellerUserInviteV1(acceptInviteRequest, options) {
        return exports.ResellerApiFp(this.configuration).acceptResellerUserInviteV1(acceptInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add customer credit
     * @summary Add Customer Credit
     * @param {string} customerOrgId
     * @param {Array<CustomerCreditRequest>} customerCreditRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    addCustomerCreditV1(customerOrgId, customerCreditRequest, options) {
        return exports.ResellerApiFp(this.configuration).addCustomerCreditV1(customerOrgId, customerCreditRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add Reseller settings
     * @summary Organization Settings
     * @param {OrganizationSettings} organizationSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    addResellerSettingsV1(organizationSettings, options) {
        return exports.ResellerApiFp(this.configuration).addResellerSettingsV1(organizationSettings, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new customer organization under a reseller organization
     * @summary Create Customer
     * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options) {
        return exports.ResellerApiFp(this.configuration).createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
     * @summary Create Reseller Organization
     * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options) {
        return exports.ResellerApiFp(this.configuration).createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a user
     * @summary Delete Reseller User
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    deleteResellerUserV1(userId, options) {
        return exports.ResellerApiFp(this.configuration).deleteResellerUserV1(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
     * @summary Get Customer Credentials
     * @param {string} customerOrgId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    getCustomerCredentialsV1(customerOrgId, options) {
        return exports.ResellerApiFp(this.configuration).getCustomerCredentialsV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get customer credits
     * @summary Get Customer Credits
     * @param {string} customerOrgId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    getCustomerCreditsV1(customerOrgId, options) {
        return exports.ResellerApiFp(this.configuration).getCustomerCreditsV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a customer organization by id under a reseller organization
     * @summary Get Customer Org
     * @param {string} customerOrgId
     * @param {boolean} [includeUsers]
     * @param {boolean} [includeResellerAdminCredentials]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    getCustomerOrganizationV1(customerOrgId, includeUsers, includeResellerAdminCredentials, options) {
        return exports.ResellerApiFp(this.configuration).getCustomerOrganizationV1(customerOrgId, includeUsers, includeResellerAdminCredentials, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get organization settings
     * @summary Get Organization Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    getOrganizationSettingsV1(options) {
        return exports.ResellerApiFp(this.configuration).getOrganizationSettingsV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get analytics data for Reseller
     * @summary Get Reseller Metrics
     * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    getResellerMetricsV1(resellerBatchMetricsRequests, options) {
        return exports.ResellerApiFp(this.configuration).getResellerMetricsV1(resellerBatchMetricsRequests, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a reseller organization by id
     * @summary Get Reseller Organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    getResellerOrganizationV1(options) {
        return exports.ResellerApiFp(this.configuration).getResellerOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get reseller pricing for customer
     * @summary Get Reseller Pricing
     * @param {string} customerOrgId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    getResellerPricingV1(customerOrgId, options) {
        return exports.ResellerApiFp(this.configuration).getResellerPricingV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the customer organizations under a reseller organization
     * @summary List Customers
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    listCustomerOrganizationsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
        return exports.ResellerApiFp(this.configuration).listCustomerOrganizationsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List of all open invites from the organization
     * @summary List Reseller User Invites
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
        return exports.ResellerApiFp(this.configuration).listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all users under the user\'s organization
     * @summary List Reseller Users
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options) {
        return exports.ResellerApiFp(this.configuration).listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Invite a new user to an organization or resend invite to the user if the user is already invited
     * @summary Invite Users
     * @param {GuestInput} guestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    sendResellerUserInviteV1(guestInput, options) {
        return exports.ResellerApiFp(this.configuration).sendResellerUserInviteV1(guestInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sync reseller stripe customer
     * @summary Stripe Sync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    stripeSyncV1(options) {
        return exports.ResellerApiFp(this.configuration).stripeSyncV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update customer pricing
     * @summary Reseller Customer Pricing Update
     * @param {string} customerOrgId
     * @param {Array<PriceUpdateRequest>} priceUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    updateCustomerPricingV1(customerOrgId, priceUpdateRequest, options) {
        return exports.ResellerApiFp(this.configuration).updateCustomerPricingV1(customerOrgId, priceUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a reseller organization
     * @summary Update Reseller Organization
     * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    updateResellerOrganizationV1(updateResellerOrganizationRequest, options) {
        return exports.ResellerApiFp(this.configuration).updateResellerOrganizationV1(updateResellerOrganizationRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update organization settings
     * @summary Organization Settings Update
     * @param {OrganizationSettings} organizationSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    updateResellerSettingsV1(organizationSettings, options) {
        return exports.ResellerApiFp(this.configuration).updateResellerSettingsV1(organizationSettings, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update user details
     * @summary Update Reseller User
     * @param {string} userId
     * @param {UpdateUserPayload} updateUserPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    updateResellerUserV1(userId, updateUserPayload, options) {
        return exports.ResellerApiFp(this.configuration).updateResellerUserV1(userId, updateUserPayload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ResellerApi = ResellerApi;
/**
 * TelephonyApi - axios parameter creator
 * @export
 */
exports.TelephonyApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get Agent Phones
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentPhonesV1: (agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling getAgentPhonesV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}/phones`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Link Phone To Agent
         * @param {string} phoneId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPhoneToAgentV1: (phoneId, agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'phoneId' is not null or undefined
            if (phoneId === null || phoneId === undefined) {
                throw new base_1.RequiredError('phoneId', 'Required parameter phoneId was null or undefined when calling linkPhoneToAgentV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling linkPhoneToAgentV1.');
            }
            const localVarPath = `/v1/telephony/phones/{phone_id}/ai-agents/{agent_id}/link`
                .replace(`{${"phone_id"}}`, encodeURIComponent(String(phoneId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Available Phones
         * @param {string} countryCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailablePhonesV1: (countryCode, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'countryCode' is not null or undefined
            if (countryCode === null || countryCode === undefined) {
                throw new base_1.RequiredError('countryCode', 'Required parameter countryCode was null or undefined when calling listAvailablePhonesV1.');
            }
            const localVarPath = `/v1/telephony/countries/{country_code}/available-phones`
                .replace(`{${"country_code"}}`, encodeURIComponent(String(countryCode)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Purchased Phones
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPurchasedPhonesV1: (countryCode, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/telephony/phones`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Supported Countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupportedCountriesV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/telephony/countries`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Purchase Phone
         * @param {NumberPurchaseRequest} numberPurchaseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasePhoneV1: (numberPurchaseRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'numberPurchaseRequest' is not null or undefined
            if (numberPurchaseRequest === null || numberPurchaseRequest === undefined) {
                throw new base_1.RequiredError('numberPurchaseRequest', 'Required parameter numberPurchaseRequest was null or undefined when calling purchasePhoneV1.');
            }
            const localVarPath = `/v1/telephony/phones`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof numberPurchaseRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(numberPurchaseRequest !== undefined ? numberPurchaseRequest : {}) : (numberPurchaseRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Release Phone
         * @param {string} phoneId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePhoneV1: (phoneId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'phoneId' is not null or undefined
            if (phoneId === null || phoneId === undefined) {
                throw new base_1.RequiredError('phoneId', 'Required parameter phoneId was null or undefined when calling releasePhoneV1.');
            }
            const localVarPath = `/v1/telephony/phones/{phone_id}`
                .replace(`{${"phone_id"}}`, encodeURIComponent(String(phoneId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Unlink Phone From Agent
         * @param {string} phoneId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPhoneFromAgentV1: (phoneId, agentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'phoneId' is not null or undefined
            if (phoneId === null || phoneId === undefined) {
                throw new base_1.RequiredError('phoneId', 'Required parameter phoneId was null or undefined when calling unlinkPhoneFromAgentV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new base_1.RequiredError('agentId', 'Required parameter agentId was null or undefined when calling unlinkPhoneFromAgentV1.');
            }
            const localVarPath = `/v1/telephony/phones/{phone_id}/ai-agents/{agent_id}/link`
                .replace(`{${"phone_id"}}`, encodeURIComponent(String(phoneId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TelephonyApi - functional programming interface
 * @export
 */
exports.TelephonyApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get Agent Phones
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentPhonesV1(agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TelephonyApiAxiosParamCreator(configuration).getAgentPhonesV1(agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Link Phone To Agent
         * @param {string} phoneId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPhoneToAgentV1(phoneId, agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TelephonyApiAxiosParamCreator(configuration).linkPhoneToAgentV1(phoneId, agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary List Available Phones
         * @param {string} countryCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailablePhonesV1(countryCode, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TelephonyApiAxiosParamCreator(configuration).listAvailablePhonesV1(countryCode, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary List Purchased Phones
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPurchasedPhonesV1(countryCode, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TelephonyApiAxiosParamCreator(configuration).listPurchasedPhonesV1(countryCode, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary List Supported Countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupportedCountriesV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TelephonyApiAxiosParamCreator(configuration).listSupportedCountriesV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Purchase Phone
         * @param {NumberPurchaseRequest} numberPurchaseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasePhoneV1(numberPurchaseRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TelephonyApiAxiosParamCreator(configuration).purchasePhoneV1(numberPurchaseRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Release Phone
         * @param {string} phoneId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePhoneV1(phoneId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TelephonyApiAxiosParamCreator(configuration).releasePhoneV1(phoneId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Unlink Phone From Agent
         * @param {string} phoneId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPhoneFromAgentV1(phoneId, agentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TelephonyApiAxiosParamCreator(configuration).unlinkPhoneFromAgentV1(phoneId, agentId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * TelephonyApi - factory interface
 * @export
 */
exports.TelephonyApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Get Agent Phones
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentPhonesV1(agentId, options) {
            return exports.TelephonyApiFp(configuration).getAgentPhonesV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Link Phone To Agent
         * @param {string} phoneId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPhoneToAgentV1(phoneId, agentId, options) {
            return exports.TelephonyApiFp(configuration).linkPhoneToAgentV1(phoneId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Available Phones
         * @param {string} countryCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailablePhonesV1(countryCode, options) {
            return exports.TelephonyApiFp(configuration).listAvailablePhonesV1(countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Purchased Phones
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPurchasedPhonesV1(countryCode, options) {
            return exports.TelephonyApiFp(configuration).listPurchasedPhonesV1(countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Supported Countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupportedCountriesV1(options) {
            return exports.TelephonyApiFp(configuration).listSupportedCountriesV1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Purchase Phone
         * @param {NumberPurchaseRequest} numberPurchaseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasePhoneV1(numberPurchaseRequest, options) {
            return exports.TelephonyApiFp(configuration).purchasePhoneV1(numberPurchaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Release Phone
         * @param {string} phoneId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePhoneV1(phoneId, options) {
            return exports.TelephonyApiFp(configuration).releasePhoneV1(phoneId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Unlink Phone From Agent
         * @param {string} phoneId
         * @param {string} agentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPhoneFromAgentV1(phoneId, agentId, options) {
            return exports.TelephonyApiFp(configuration).unlinkPhoneFromAgentV1(phoneId, agentId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TelephonyApi - object-oriented interface
 * @export
 * @class TelephonyApi
 * @extends {BaseAPI}
 */
class TelephonyApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get Agent Phones
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    getAgentPhonesV1(agentId, options) {
        return exports.TelephonyApiFp(this.configuration).getAgentPhonesV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Link Phone To Agent
     * @param {string} phoneId
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    linkPhoneToAgentV1(phoneId, agentId, options) {
        return exports.TelephonyApiFp(this.configuration).linkPhoneToAgentV1(phoneId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Available Phones
     * @param {string} countryCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    listAvailablePhonesV1(countryCode, options) {
        return exports.TelephonyApiFp(this.configuration).listAvailablePhonesV1(countryCode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Purchased Phones
     * @param {string} [countryCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    listPurchasedPhonesV1(countryCode, options) {
        return exports.TelephonyApiFp(this.configuration).listPurchasedPhonesV1(countryCode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Supported Countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    listSupportedCountriesV1(options) {
        return exports.TelephonyApiFp(this.configuration).listSupportedCountriesV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Purchase Phone
     * @param {NumberPurchaseRequest} numberPurchaseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    purchasePhoneV1(numberPurchaseRequest, options) {
        return exports.TelephonyApiFp(this.configuration).purchasePhoneV1(numberPurchaseRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Release Phone
     * @param {string} phoneId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    releasePhoneV1(phoneId, options) {
        return exports.TelephonyApiFp(this.configuration).releasePhoneV1(phoneId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Unlink Phone From Agent
     * @param {string} phoneId
     * @param {string} agentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    unlinkPhoneFromAgentV1(phoneId, agentId, options) {
        return exports.TelephonyApiFp(this.configuration).unlinkPhoneFromAgentV1(phoneId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TelephonyApi = TelephonyApi;
/**
 * UIApi - axios parameter creator
 * @export
 */
exports.UIApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary List Action Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionTemplatesV1: (language, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/ui/action-templates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Products
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {Array<string>} [tags] Filter products by specific tags
         * @param {Array<string>} [productIds] Filter by specific product IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsDetailedV1: (searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/ui/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }
            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }
            if (productIds) {
                localVarQueryParameter['product_ids'] = productIds;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Prompt Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptTemplatesV1: (language, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/ui/prompt-templates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Role Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleTemplatesV1: (language, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/ui/role-templates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * UIApi - functional programming interface
 * @export
 */
exports.UIApiFp = function (configuration) {
    return {
        /**
         *
         * @summary List Action Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionTemplatesV1(language, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UIApiAxiosParamCreator(configuration).listActionTemplatesV1(language, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary List Products
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {Array<string>} [tags] Filter products by specific tags
         * @param {Array<string>} [productIds] Filter by specific product IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UIApiAxiosParamCreator(configuration).listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary List Prompt Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptTemplatesV1(language, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UIApiAxiosParamCreator(configuration).listPromptTemplatesV1(language, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary List Role Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleTemplatesV1(language, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UIApiAxiosParamCreator(configuration).listRoleTemplatesV1(language, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * UIApi - factory interface
 * @export
 */
exports.UIApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary List Action Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionTemplatesV1(language, options) {
            return exports.UIApiFp(configuration).listActionTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Products
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {Array<string>} [tags] Filter products by specific tags
         * @param {Array<string>} [productIds] Filter by specific product IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options) {
            return exports.UIApiFp(configuration).listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Prompt Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptTemplatesV1(language, options) {
            return exports.UIApiFp(configuration).listPromptTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Role Templates
         * @param {string} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleTemplatesV1(language, options) {
            return exports.UIApiFp(configuration).listRoleTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UIApi - object-oriented interface
 * @export
 * @class UIApi
 * @extends {BaseAPI}
 */
class UIApi extends base_1.BaseAPI {
    /**
     *
     * @summary List Action Templates
     * @param {string} [language]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    listActionTemplatesV1(language, options) {
        return exports.UIApiFp(this.configuration).listActionTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Products
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {Array<string>} [tags] Filter products by specific tags
     * @param {Array<string>} [productIds] Filter by specific product IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options) {
        return exports.UIApiFp(this.configuration).listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Prompt Templates
     * @param {string} [language]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    listPromptTemplatesV1(language, options) {
        return exports.UIApiFp(this.configuration).listPromptTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Role Templates
     * @param {string} [language]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    listRoleTemplatesV1(language, options) {
        return exports.UIApiFp(this.configuration).listRoleTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UIApi = UIApi;
/**
 * VoiceModelsApi - axios parameter creator
 * @export
 */
exports.VoiceModelsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get List Of Voices Available For Conversations
         * @summary Get List Of Voices Available For Conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoiceModelsV1: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/voice-models`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * VoiceModelsApi - functional programming interface
 * @export
 */
exports.VoiceModelsApiFp = function (configuration) {
    return {
        /**
         * Get List Of Voices Available For Conversations
         * @summary Get List Of Voices Available For Conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoiceModelsV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.VoiceModelsApiAxiosParamCreator(configuration).listVoiceModelsV1(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * VoiceModelsApi - factory interface
 * @export
 */
exports.VoiceModelsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Get List Of Voices Available For Conversations
         * @summary Get List Of Voices Available For Conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoiceModelsV1(options) {
            return exports.VoiceModelsApiFp(configuration).listVoiceModelsV1(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * VoiceModelsApi - object-oriented interface
 * @export
 * @class VoiceModelsApi
 * @extends {BaseAPI}
 */
class VoiceModelsApi extends base_1.BaseAPI {
    /**
     * Get List Of Voices Available For Conversations
     * @summary Get List Of Voices Available For Conversations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceModelsApi
     */
    listVoiceModelsV1(options) {
        return exports.VoiceModelsApiFp(this.configuration).listVoiceModelsV1(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.VoiceModelsApi = VoiceModelsApi;
