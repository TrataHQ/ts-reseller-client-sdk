// tslint:disable
/**
 * Trata AI API
 * Human like conversation to answer calls, drive engagement, automate follow-ups & schedule bookings 24/7  with end to end integrations ensuring you never miss a sales enquiry.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AIAgentInput
 */
export interface AIAgentInput {
    /**
     * Name of the AI agent
     * @type {string}
     * @memberof AIAgentInput
     */
    name: string;
    /**
     * Image URL for the AI agent
     * @type {string}
     * @memberof AIAgentInput
     */
    imageUrl: string;
    /**
     * Mission of the AI agent
     * @type {Mission}
     * @memberof AIAgentInput
     */
    mission?: Mission | null;
    /**
     * Status of the AI agent
     * @type {Status}
     * @memberof AIAgentInput
     */
    status: Status;
    /**
     * Role of the AI agent in the company
     * @type {string}
     * @memberof AIAgentInput
     */
    role: string;
    /**
     * Description of the role of the AI agent
     * @type {string}
     * @memberof AIAgentInput
     */
    roleDescription: string;
    /**
     * Timezone of the AI agent used for scheduling meetings
     * @type {string}
     * @memberof AIAgentInput
     */
    timezone: string;
    /**
     * Voice of the AI agent
     * @type {VoiceInput}
     * @memberof AIAgentInput
     */
    voice?: VoiceInput | null;
}
/**
 * AI agent configured by businesses
 * @export
 * @interface AIAgentOutput
 */
export interface AIAgentOutput {
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    imageUrl?: string;
    /**
     * 
     * @type {Mission}
     * @memberof AIAgentOutput
     */
    mission?: Mission | null;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    roleDescription?: string;
    /**
     * 
     * @type {Transcriber}
     * @memberof AIAgentOutput
     */
    transcriber?: Transcriber | null;
    /**
     * 
     * @type {IntelligenceProvider}
     * @memberof AIAgentOutput
     */
    intelligenceProvider?: IntelligenceProvider | null;
    /**
     * 
     * @type {VoiceOutput}
     * @memberof AIAgentOutput
     */
    voice?: VoiceOutput | null;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    timezone?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof AIAgentOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Accent {
    American = 'American',
    Indian = 'Indian',
    Australian = 'Australian',
    British = 'British',
    Hindi = 'Hindi'
}

/**
 * 
 * @export
 * @interface AcceptInviteRequest
 */
export interface AcceptInviteRequest {
    /**
     * Name of the user
     * @type {string}
     * @memberof AcceptInviteRequest
     */
    name?: string | null;
}
/**
 * 
 * @export
 * @interface ActionInput
 */
export interface ActionInput {
    /**
     * Name of the action
     * @type {string}
     * @memberof ActionInput
     */
    name: string;
    /**
     * Description about the action and it should also contain when the action should be triggered
     * @type {string}
     * @memberof ActionInput
     */
    description?: string | null;
    /**
     * Parameters for the action. It should be a JSON schema object
     * @type {object}
     * @memberof ActionInput
     */
    parameters: object;
    /**
     * Endpoint for the action
     * @type {HttpActionEndpoint | InternalActionEndpoint}
     * @memberof ActionInput
     */
    endpoint: HttpActionEndpoint | InternalActionEndpoint;
    /**
     * Text to be rendered to user when action is invoked
     * @type {string}
     * @memberof ActionInput
     */
    userWaitingText?: string | null;
    /**
     * Text to be rendered to user when action is successful
     * @type {string}
     * @memberof ActionInput
     */
    userSuccessText?: string | null;
    /**
     * Text to be rendered to user when action is not successful
     * @type {string}
     * @memberof ActionInput
     */
    userErrorText?: string | null;
    /**
     * Trigger who invokes the action
     * @type {ActionInvocationTrigger}
     * @memberof ActionInput
     */
    invocationTrigger: ActionInvocationTrigger;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ActionInvocationTrigger {
    UserQuery = 'user_query',
    WebhookConversationStart = 'webhook.conversation_start',
    WebhookConversationEnd = 'webhook.conversation_end'
}

/**
 * Action entity to store the actions which can be performed by ai agents
 * @export
 * @interface ActionOutput
 */
export interface ActionOutput {
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    description?: string | null;
    /**
     * 
     * @type {object}
     * @memberof ActionOutput
     */
    parameters?: object | null;
    /**
     * 
     * @type {object}
     * @memberof ActionOutput
     */
    endpoint?: object | null;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    invocationTrigger?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    userWaitingText?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    userSuccessText?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    userErrorText?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface AddressInput
 */
export interface AddressInput {
    /**
     * Address line 1
     * @type {string}
     * @memberof AddressInput
     */
    line1: string;
    /**
     * Address line 2
     * @type {string}
     * @memberof AddressInput
     */
    line2?: string | null;
    /**
     * City
     * @type {string}
     * @memberof AddressInput
     */
    city?: string | null;
    /**
     * State
     * @type {string}
     * @memberof AddressInput
     */
    state?: string | null;
    /**
     * Country
     * @type {string}
     * @memberof AddressInput
     */
    country: string;
}
/**
 * 
 * @export
 * @interface AddressOutput
 */
export interface AddressOutput {
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    line1: string;
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    line2: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    city: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    state: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressOutput
     */
    country: string | null;
}
/**
 * 
 * @export
 * @interface AgentConfig
 */
export interface AgentConfig {
    /**
     * Enum class representing transcriber
     * @type {string}
     * @memberof AgentConfig
     */
    transcriber: string;
    /**
     * Enum class representing intelligence provider
     * @type {string}
     * @memberof AgentConfig
     */
    intelligenceProvider: string;
    /**
     * 
     * @type {string}
     * @memberof AgentConfig
     */
    synthesizer: string;
    /**
     * 
     * @type {string}
     * @memberof AgentConfig
     */
    embeddingsModelConfig: string;
    /**
     * 
     * @type {string}
     * @memberof AgentConfig
     */
    hiveStorageConfig: string;
    /**
     * 
     * @type {string}
     * @memberof AgentConfig
     */
    fillersConfig?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum AggregationFormula {
    COUNT = 'COUNT',
    SUM = 'SUM',
    MEDIAN = 'MEDIAN'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum AggregationPeriod {
    MONTHLY = 'MONTHLY',
    WEEKLY = 'WEEKLY',
    DAILY = 'DAILY'
}

/**
 * 
 * @export
 * @interface ApiKeyRequest
 */
export interface ApiKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiKeyRequest
     */
    key_type?: string | null;
}
/**
 * 
 * @export
 * @interface AvailablePhoneNumber
 */
export interface AvailablePhoneNumber {
    /**
     * 
     * @type {string}
     * @memberof AvailablePhoneNumber
     */
    phoneNumber: string;
    /**
     * 
     * @type {string}
     * @memberof AvailablePhoneNumber
     */
    countryCode: string;
    /**
     * 
     * @type {string}
     * @memberof AvailablePhoneNumber
     */
    locality: string | null;
    /**
     * 
     * @type {string}
     * @memberof AvailablePhoneNumber
     */
    region: string | null;
}
/**
 * 
 * @export
 * @interface BaseResponse
 */
export interface BaseResponse {
    /**
     * Address line 1
     * @type {string}
     * @memberof BaseResponse
     */
    message: string;
}
/**
 * 
 * @export
 * @interface BatchMetricsRequests
 */
export interface BatchMetricsRequests {
    /**
     * 
     * @type {Array<MetricsRequest>}
     * @memberof BatchMetricsRequests
     */
    requests: Array<MetricsRequest>;
}
/**
 * 
 * @export
 * @interface BatchMetricsResponse
 */
export interface BatchMetricsResponse {
    /**
     * 
     * @type {Array<MetricsResponse>}
     * @memberof BatchMetricsResponse
     */
    responses: Array<MetricsResponse>;
}
/**
 * 
 * @export
 * @interface BodyCreateCustomerOrganizationV1
 */
export interface BodyCreateCustomerOrganizationV1 {
    /**
     * 
     * @type {OrganizationInput}
     * @memberof BodyCreateCustomerOrganizationV1
     */
    org: OrganizationInput;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateCustomerOrganizationV1
     */
    adminUserName: string;
}
/**
 * 
 * @export
 * @interface BodyCreateOrganizationV1
 */
export interface BodyCreateOrganizationV1 {
    /**
     * 
     * @type {OrganizationInput}
     * @memberof BodyCreateOrganizationV1
     */
    org: OrganizationInput;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateOrganizationV1
     */
    adminUserName: string;
}
/**
 * 
 * @export
 * @interface BodyCreateResellerOrganizationV1
 */
export interface BodyCreateResellerOrganizationV1 {
    /**
     * 
     * @type {OrganizationInput}
     * @memberof BodyCreateResellerOrganizationV1
     */
    org: OrganizationInput;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateResellerOrganizationV1
     */
    adminUserName: string;
}
/**
 * 
 * @export
 * @interface BodyUploadFileV1
 */
export interface BodyUploadFileV1 {
    /**
     * 
     * @type {Array<any>}
     * @memberof BodyUploadFileV1
     */
    files: Array<any>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CallSentiment {
    Positive = 'positive',
    Negative = 'negative',
    Neutral = 'neutral'
}

/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * Notes or comments to record
     * @type {string}
     * @memberof Comment
     */
    comment: string;
    /**
     * Star rating to record
     * @type {number}
     * @memberof Comment
     */
    rating: number;
}
/**
 * This represents the connection between the user and the assistant
 * @export
 * @interface Connection
 */
export interface Connection {
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    sourceName?: string;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    sourceId?: string;
    /**
     * 
     * @type {object}
     * @memberof Connection
     */
    sourceProps?: object | null;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    agentId?: string;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    prospectId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface ConnectionSource
 */
export interface ConnectionSource {
    /**
     * Name of the source
     * @type {string}
     * @memberof ConnectionSource
     */
    sourceName?: ConnectionSourceSourceNameEnum;
    /**
     * Unique identifier for the source
     * @type {string}
     * @memberof ConnectionSource
     */
    sourceId: string;
    /**
     * Extra properties of source
     * @type {object}
     * @memberof ConnectionSource
     */
    sourceProps: object;
}

/**
    * @export
    * @enum {string}
    */
export enum ConnectionSourceSourceNameEnum {
    TWILIO = 'TWILIO',
    PLIVO = 'PLIVO',
    BROWSER = 'BROWSER'
}

/**
 * Expected output of the post conversation task
 * @export
 * @interface ConversationAnalyticsModel
 */
export interface ConversationAnalyticsModel {
    /**
     * Summary of the conversation happened with important details on the conversation. The summary should be concise and to the point. It should contain the important details of the conversation like name, phone number, email, address and any other details shared by the user.
     * @type {string}
     * @memberof ConversationAnalyticsModel
     */
    summary: string;
    /**
     * List of action items and the next steps to be performed from the conversation details.
     * @type {Array<string>}
     * @memberof ConversationAnalyticsModel
     */
    action_items: Array<string> | null;
    /**
     * If the user has given consent to store the audio of the conversation. Unless the user explicitly says yes, this should be false.
     * @type {boolean}
     * @memberof ConversationAnalyticsModel
     */
    is_audio_consent_given: boolean;
    /**
     * Extracted email address of the caller from the conversation details. Email should be a valid email address format
     * @type {string}
     * @memberof ConversationAnalyticsModel
     */
    email_address_of_caller: string | null;
    /**
     * Extracted name of the caller from the conversation details.
     * @type {string}
     * @memberof ConversationAnalyticsModel
     */
    name_of_caller: string | null;
    /**
     * Extracted phone number of the caller from the conversation details.
     * @type {string}
     * @memberof ConversationAnalyticsModel
     */
    phone_number_of_caller: string | null;
    /**
     * Extracted address of the caller from the conversation details.
     * @type {string}
     * @memberof ConversationAnalyticsModel
     */
    address_of_caller: string | null;
    /**
     * Sentiment of the caller based on the conversation details.
     * @type {CallSentiment}
     * @memberof ConversationAnalyticsModel
     */
    sentiment_of_caller: CallSentiment;
    /**
     * Status of the prospect after this conversation.
     * @type {ProspectStatus}
     * @memberof ConversationAnalyticsModel
     */
    prospectStatus: ProspectStatus | null;
}
/**
 * 
 * @export
 * @interface ConversationEndEvent
 */
export interface ConversationEndEvent {
    /**
     * 
     * @type {string}
     * @memberof ConversationEndEvent
     */
    timestamp: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationEndEvent
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationEndEvent
     */
    event_name: string;
    /**
     * 
     * @type {ConversationEndEventPayload}
     * @memberof ConversationEndEvent
     */
    payload?: ConversationEndEventPayload;
}
/**
 * 
 * @export
 * @interface ConversationEndEventPayload
 */
export interface ConversationEndEventPayload {
    /**
     * 
     * @type {ConversationOutput}
     * @memberof ConversationEndEventPayload
     */
    conversation: ConversationOutput;
}
/**
 * Any feedback added to the conversation by business is managed here.
 * @export
 * @interface ConversationFeedback
 */
export interface ConversationFeedback {
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    conversationId?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    feedback?: string;
    /**
     * 
     * @type {number}
     * @memberof ConversationFeedback
     */
    rating?: number;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationFeedback
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface ConversationInput
 */
export interface ConversationInput {
    /**
     * Source from where the conversation originated. This can be device id, phone number, etc.
     * @type {string}
     * @memberof ConversationInput
     */
    source: string;
    /**
     * Type of the conversation source
     * @type {ConversationSourceType}
     * @memberof ConversationInput
     */
    sourceType: ConversationSourceType;
    /**
     * AI agent which handled the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    agentId: string;
    /**
     * URL to the full transcript of the conversation
     * @type {Array<DialogLine>}
     * @memberof ConversationInput
     */
    transcriptText?: Array<DialogLine> | null;
    /**
     * Summary of the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    transcriptSummary?: string | null;
    /**
     * URL to the recording of the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    transcriptRecordingUrl?: string | null;
    /**
     * Start time of the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    timestampStart: string;
    /**
     * End time of the conversation
     * @type {string}
     * @memberof ConversationInput
     */
    timestampEnd?: string | null;
    /**
     * Analytics of the conversation
     * @type {ConversationAnalyticsModel}
     * @memberof ConversationInput
     */
    conversationAnalytics?: ConversationAnalyticsModel | null;
    /**
     * Comments from the admin on the conversation
     * @type {Array<Comment>}
     * @memberof ConversationInput
     */
    adminComments?: Array<Comment> | null;
}
/**
 * Any conversation happening between the end user and assistant is stored in this table
 * @export
 * @interface ConversationOutput
 */
export interface ConversationOutput {
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    prospectId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    source?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    sourceType?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    aiAgentId?: string;
    /**
     * 
     * @type {Array<DialogLine>}
     * @memberof ConversationOutput
     */
    transcriptText?: Array<DialogLine> | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    transcriptSummary?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    transcriptRecordingUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    timestampStart?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    timestampEnd?: string | null;
    /**
     * Analytics of the conversation
     * @type {ConversationAnalyticsModel}
     * @memberof ConversationOutput
     */
    conversationAnalytics?: ConversationAnalyticsModel | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ConversationSourceType {
    BROWSER = 'BROWSER',
    TWILIO = 'TWILIO',
    PLIVO = 'PLIVO'
}

/**
 * 
 * @export
 * @interface ConversationStartEvent
 */
export interface ConversationStartEvent {
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEvent
     */
    timestamp: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEvent
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEvent
     */
    event_name: string;
    /**
     * 
     * @type {ConversationStartEventPayload}
     * @memberof ConversationStartEvent
     */
    payload?: ConversationStartEventPayload;
}
/**
 * 
 * @export
 * @interface ConversationStartEventPayload
 */
export interface ConversationStartEventPayload {
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEventPayload
     */
    type: ConversationStartEventPayloadTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEventPayload
     */
    connection_id: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEventPayload
     */
    conversation_id: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEventPayload
     */
    ai_agent_id: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationStartEventPayload
     */
    org_id: string;
    /**
     * 
     * @type {object}
     * @memberof ConversationStartEventPayload
     */
    caller_id: object | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ConversationStartEventPayloadTypeEnum {
    ConversationStart = 'conversation_start'
}

/**
 * 
 * @export
 * @interface CountryInfo
 */
export interface CountryInfo {
    /**
     * 
     * @type {string}
     * @memberof CountryInfo
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof CountryInfo
     */
    name: string;
}
/**
 * Credits details of the business
 * @export
 * @interface Credit
 */
export interface Credit {
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    creditTypeName?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    totalAvailable?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    consumed?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    durationStart?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    durationEnd?: string;
}
/**
 * 
 * @export
 * @interface CustomerCreditRequest
 */
export interface CustomerCreditRequest {
    /**
     * Credit type name
     * @type {string}
     * @memberof CustomerCreditRequest
     */
    creditTypeName: string;
    /**
     * Credit
     * @type {string}
     * @memberof CustomerCreditRequest
     */
    credit: string;
    /**
     * Start date
     * @type {string}
     * @memberof CustomerCreditRequest
     */
    startDate: string;
    /**
     * End date
     * @type {string}
     * @memberof CustomerCreditRequest
     */
    endDate: string;
}
/**
 * 
 * @export
 * @interface DialogLine
 */
export interface DialogLine {
    /**
     * 
     * @type {string}
     * @memberof DialogLine
     */
    speaker: string;
    /**
     * 
     * @type {string}
     * @memberof DialogLine
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof DialogLine
     */
    timestamp: string;
    /**
     * 
     * @type {string}
     * @memberof DialogLine
     */
    message_id: string;
}
/**
 * 
 * @export
 * @interface ExternalReference
 */
export interface ExternalReference {
    /**
     * External service provider name
     * @type {string}
     * @memberof ExternalReference
     */
    providerName: string;
    /**
     * External service identifier
     * @type {string}
     * @memberof ExternalReference
     */
    id: string;
    /**
     * Props for the external reference
     * @type {object}
     * @memberof ExternalReference
     */
    providerProps?: object | null;
}
/**
 * 
 * @export
 * @interface ExternalServicePorviderInput
 */
export interface ExternalServicePorviderInput {
    /**
     * External service provider name
     * @type {string}
     * @memberof ExternalServicePorviderInput
     */
    providerName: string;
    /**
     * External service identifier
     * @type {string}
     * @memberof ExternalServicePorviderInput
     */
    id: string;
    /**
     * Props for the external service provider
     * @type {object}
     * @memberof ExternalServicePorviderInput
     */
    providerProps: object | null;
}
/**
 * 
 * @export
 * @interface ExternalServicePorviderOutput
 */
export interface ExternalServicePorviderOutput {
    /**
     * 
     * @type {string}
     * @memberof ExternalServicePorviderOutput
     */
    providerName: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalServicePorviderOutput
     */
    id: string;
    /**
     * 
     * @type {object}
     * @memberof ExternalServicePorviderOutput
     */
    providerProps: object | null;
}
/**
 * Stores the map of file id with respective file URL in storage manager
 * @export
 * @interface Files
 */
export interface Files {
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    fileName?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    fileUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    updatedAt?: string;
}
/**
 * Guest users who are not verified by Trata yet
 * @export
 * @interface GuestInput
 */
export interface GuestInput {
    /**
     * 
     * @type {string}
     * @memberof GuestInput
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof GuestInput
     */
    role: string;
}
/**
 * Guest users who are not verified by Trata yet. They will not be able to use Trata until they are verified.
 * @export
 * @interface GuestOutput
 */
export interface GuestOutput {
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    role?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GuestOutput
     */
    isEmailVerified?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    last_sent_date?: string;
    /**
     * 
     * @type {number}
     * @memberof GuestOutput
     */
    sent_count?: number;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof GuestOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * Reference to all business knowledge base will be stored in Hive
 * @export
 * @interface Hive
 */
export interface Hive {
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    orgId?: string;
    /**
     * 
     * @type {HiveContentOutput}
     * @memberof Hive
     */
    content: HiveContentOutput;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Hive
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface HiveContentInput
 */
export interface HiveContentInput {
    /**
     * 
     * @type {HiveType}
     * @memberof HiveContentInput
     */
    hiveType: HiveType;
    /**
     * URL of the content
     * @type {string}
     * @memberof HiveContentInput
     */
    url?: string | null;
    /**
     * List of file ids to be referenced for the hive
     * @type {Array<string>}
     * @memberof HiveContentInput
     */
    file_ids?: Array<string> | null;
    /**
     * To recursively crawl child pages, add this as props {\"crawl_child_pages\": true},  \"depth\": \"3\"
     * @type {object}
     * @memberof HiveContentInput
     */
    hiveProps?: object | null;
}
/**
 * 
 * @export
 * @interface HiveContentOutput
 */
export interface HiveContentOutput {
    /**
     * 
     * @type {HiveType}
     * @memberof HiveContentOutput
     */
    hiveType: HiveType;
    /**
     * URL of the content
     * @type {string}
     * @memberof HiveContentOutput
     */
    url?: string | null;
    /**
     * List of files to be referenced for the hive
     * @type {Array<Files>}
     * @memberof HiveContentOutput
     */
    files?: Array<Files> | null;
    /**
     * To recursively crawl child pages, add this as props {\"crawl_child_pages\": true},  \"depth\": \"3\"
     * @type {object}
     * @memberof HiveContentOutput
     */
    hiveProps?: object | null;
    /**
     * To add any internal props, add this as props {\"last_crawl_time\": \"123123123123\"}
     * @type {object}
     * @memberof HiveContentOutput
     */
    internalProps?: object | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum HiveType {
    WEBSITE = 'WEBSITE',
    GOOGLEDOCS = 'GOOGLE_DOCS',
    DOCS = 'DOCS',
    TRANSCRIPTS = 'TRANSCRIPTS'
}

/**
 * 
 * @export
 * @interface HttpActionEndpoint
 */
export interface HttpActionEndpoint {
    /**
     * Action endpoint URL
     * @type {string}
     * @memberof HttpActionEndpoint
     */
    url: string;
    /**
     * Method to be used for invoking the endpoint
     * @type {string}
     * @memberof HttpActionEndpoint
     */
    method?: HttpActionEndpointMethodEnum;
    /**
     * Headers for the endpoint
     * @type {object}
     * @memberof HttpActionEndpoint
     */
    headers?: object | null;
    /**
     * Payload for the endpoint
     * @type {object}
     * @memberof HttpActionEndpoint
     */
    payload?: object | null;
}

/**
    * @export
    * @enum {string}
    */
export enum HttpActionEndpointMethodEnum {
    GET = 'GET',
    POST = 'POST'
}

/**
 * 
 * @export
 * @interface IntelligenceProvider
 */
export interface IntelligenceProvider {
    /**
     * 
     * @type {string}
     * @memberof IntelligenceProvider
     */
    providerName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IntelligenceProvider
     */
    model?: string | null;
    /**
     * 
     * @type {object}
     * @memberof IntelligenceProvider
     */
    providerProps?: object | null;
}
/**
 * Internal action endpoint to be used for calling the action inside the module. Not used by external users
 * @export
 * @interface InternalActionEndpoint
 */
export interface InternalActionEndpoint {
    /**
     * Module where the action is defined
     * @type {string}
     * @memberof InternalActionEndpoint
     */
    module: string;
    /**
     * Function to be called inside the module
     * @type {string}
     * @memberof InternalActionEndpoint
     */
    _function: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Language {
    English = 'English',
    Spanish = 'Spanish',
    Hindi = 'Hindi'
}

/**
 * 
 * @export
 * @interface LanguageAccentCombo
 */
export interface LanguageAccentCombo {
    /**
     * 
     * @type {Language}
     * @memberof LanguageAccentCombo
     */
    language: Language;
    /**
     * 
     * @type {Accent}
     * @memberof LanguageAccentCombo
     */
    accent: Accent;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MetricName {
    CALLS = 'CALLS',
    CALLDURATION = 'CALL_DURATION',
    APPOINTMENTSCHEDULED = 'APPOINTMENT_SCHEDULED',
    PROSPECTS = 'PROSPECTS',
    INTERESTED = 'INTERESTED',
    NOTINTERESTED = 'NOT_INTERESTED'
}

/**
 * 
 * @export
 * @interface MetricResponseDataPoint
 */
export interface MetricResponseDataPoint {
    /**
     * Timestamp of the data point
     * @type {string}
     * @memberof MetricResponseDataPoint
     */
    timestamp: string;
    /**
     * Value which will be a string representation of integer or floating number
     * @type {string}
     * @memberof MetricResponseDataPoint
     */
    value: string;
}
/**
 * 
 * @export
 * @interface MetricsRequest
 */
export interface MetricsRequest {
    /**
     * Unique identifier for the metric request. This can be helped to co-relate the request and response
     * @type {string}
     * @memberof MetricsRequest
     */
    id: string;
    /**
     * Name of the metric
     * @type {MetricName}
     * @memberof MetricsRequest
     */
    name: MetricName;
    /**
     * Start date to get metric request
     * @type {string}
     * @memberof MetricsRequest
     */
    fromDate: string;
    /**
     * End date until get metric request
     * @type {string}
     * @memberof MetricsRequest
     */
    toDate: string;
    /**
     * Aggregation period for the metric request
     * @type {AggregationPeriod}
     * @memberof MetricsRequest
     */
    aggregationPeriod: AggregationPeriod;
    /**
     * Aggregation formula for the metric request
     * @type {AggregationFormula}
     * @memberof MetricsRequest
     */
    aggregationFormula: AggregationFormula;
}
/**
 * 
 * @export
 * @interface MetricsResponse
 */
export interface MetricsResponse {
    /**
     * Unique identifier for the metric response. This will help co-relate the request and response
     * @type {string}
     * @memberof MetricsResponse
     */
    id: string;
    /**
     * Name of the metric
     * @type {MetricName}
     * @memberof MetricsResponse
     */
    name: MetricName;
    /**
     * List of data points for the metric response
     * @type {Array<MetricResponseDataPoint>}
     * @memberof MetricsResponse
     */
    datapoints: Array<MetricResponseDataPoint>;
}
/**
 * 
 * @export
 * @interface Mission
 */
export interface Mission {
    /**
     * Full prompt instructions for LLM model
     * @type {string}
     * @memberof Mission
     */
    prompt?: string | null;
    /**
     * Objective of the mission
     * @type {string}
     * @memberof Mission
     */
    objective?: string | null;
    /**
     * Greeting message to be read by the AI agent
     * @type {string}
     * @memberof Mission
     */
    greeting: string | null;
    /**
     * Sequence of actions to be performed by the AI agent during the conversation.
     * @type {Array<Sequence>}
     * @memberof Mission
     */
    sequence?: Array<Sequence> | null;
    /**
     * Conclusion message to be read by the AI agent
     * @type {string}
     * @memberof Mission
     */
    farewell?: string | null;
}
/**
 * 
 * @export
 * @interface NumberPurchaseRequest
 */
export interface NumberPurchaseRequest {
    /**
     * 
     * @type {string}
     * @memberof NumberPurchaseRequest
     */
    countryCode: string;
    /**
     * 
     * @type {string}
     * @memberof NumberPurchaseRequest
     */
    phoneNumber: string;
}
/**
 * 
 * @export
 * @interface OrgUsersPriceCredits
 */
export interface OrgUsersPriceCredits {
    /**
     * 
     * @type {OrganizationOutput}
     * @memberof OrgUsersPriceCredits
     */
    organization: OrganizationOutput;
    /**
     * 
     * @type {Array<User>}
     * @memberof OrgUsersPriceCredits
     */
    users: Array<User>;
    /**
     * 
     * @type {Price}
     * @memberof OrgUsersPriceCredits
     */
    price?: Price | null;
    /**
     * 
     * @type {Array<Credit>}
     * @memberof OrgUsersPriceCredits
     */
    credits?: Array<Credit> | null;
}
/**
 * 
 * @export
 * @interface OrgWithUsers
 */
export interface OrgWithUsers {
    /**
     * 
     * @type {OrganizationOutput}
     * @memberof OrgWithUsers
     */
    organization: OrganizationOutput;
    /**
     * 
     * @type {Array<User>}
     * @memberof OrgWithUsers
     */
    users: Array<User>;
}
/**
 * Organization represents the business using Trata and all users are associated to this business entity
 * @export
 * @interface OrganizationInput
 */
export interface OrganizationInput {
    /**
     * Name of the organization
     * @type {string}
     * @memberof OrganizationInput
     */
    name: string;
    /**
     * Address of the organization
     * @type {AddressInput}
     * @memberof OrganizationInput
     */
    address?: AddressInput | null;
    /**
     * Tax details of the organization
     * @type {TaxDetailsInput}
     * @memberof OrganizationInput
     */
    tax?: TaxDetailsInput | null;
    /**
     * External references for the organization
     * @type {Array<ExternalServicePorviderInput>}
     * @memberof OrganizationInput
     */
    externalReferenceIds?: Array<ExternalServicePorviderInput> | null;
    /**
     * Configurations for all the agents going to be created in this org
     * @type {AgentConfig}
     * @memberof OrganizationInput
     */
    agentConfig?: AgentConfig | null;
}
/**
 * Organization represents the business using Trata and all users are associated to this business entity
 * @export
 * @interface OrganizationOutput
 */
export interface OrganizationOutput {
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    name?: string;
    /**
     * 
     * @type {AgentConfig}
     * @memberof OrganizationOutput
     */
    config: AgentConfig;
    /**
     * 
     * @type {AddressOutput}
     * @memberof OrganizationOutput
     */
    address: AddressOutput | null;
    /**
     * 
     * @type {TaxDetailsOutput}
     * @memberof OrganizationOutput
     */
    tax: TaxDetailsOutput | null;
    /**
     * 
     * @type {Array<ExternalServicePorviderOutput>}
     * @memberof OrganizationOutput
     */
    externalReferenceIds: Array<ExternalServicePorviderOutput> | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationOutput
     */
    updatedAt?: string;
    /**
     * If the Organization is created by reseller, this field will have the reseller org id as the parent organization id
     * @type {string}
     * @memberof OrganizationOutput
     */
    parentOrgId?: string;
    /**
     * Type of the organization. Currently only CONSUMER & RESELLER are supported
     * @type {string}
     * @memberof OrganizationOutput
     */
    orgType?: string | null;
}
/**
 * Organization settings details of the business
 * @export
 * @interface OrganizationSettings
 */
export interface OrganizationSettings {
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    domain?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    stripeKey?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    brandColor?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    buttonColor?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    favicon?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    logo?: string;
}
/**
 * 
 * @export
 * @interface PlanDetails
 */
export interface PlanDetails {
    /**
     * Product name
     * @type {string}
     * @memberof PlanDetails
     */
    productName: string;
    /**
     * Product description
     * @type {string}
     * @memberof PlanDetails
     */
    description: string;
    /**
     * 
     * @type {Array<Price>}
     * @memberof PlanDetails
     */
    pricingDetails: Array<Price>;
}
/**
 * Price details of the business
 * @export
 * @interface Price
 */
export interface Price {
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    parentOrgId?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    planName?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    priceName?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof Price
     */
    price?: number;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    currency?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    interval?: string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    stripePriceId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    stripeProductId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    priceType?: string;
}
/**
 * 
 * @export
 * @interface PriceUpdateRequest
 */
export interface PriceUpdateRequest {
    /**
     * Product name
     * @type {string}
     * @memberof PriceUpdateRequest
     */
    productName: string;
    /**
     * Price name
     * @type {string}
     * @memberof PriceUpdateRequest
     */
    priceName: string;
    /**
     * 
     * @type {number}
     * @memberof PriceUpdateRequest
     */
    newPrice: number;
}
/**
 * 
 * @export
 * @interface ProductInput
 */
export interface ProductInput {
    /**
     * Product is active or not
     * @type {boolean}
     * @memberof ProductInput
     */
    active: boolean;
    /**
     * Default price of the product this is represented in the lowest currency denomination. Eg: 1000 for $10
     * @type {number}
     * @memberof ProductInput
     */
    defaultPrice: number;
    /**
     * Currency of the product
     * @type {string}
     * @memberof ProductInput
     */
    currency: ProductInputCurrencyEnum;
    /**
     * Description of the product
     * @type {string}
     * @memberof ProductInput
     */
    description: string;
    /**
     * Name of the product
     * @type {string}
     * @memberof ProductInput
     */
    name: string;
    /**
     * Product is shippable or not. Service is not shippable
     * @type {boolean}
     * @memberof ProductInput
     */
    shippable?: boolean;
    /**
     * List of features of the product
     * @type {Array<string>}
     * @memberof ProductInput
     */
    features?: Array<string> | null;
    /**
     * Product requires appointment scheduling or not
     * @type {boolean}
     * @memberof ProductInput
     */
    scheduleAppointment?: boolean;
    /**
     * Properties of the product
     * @type {object}
     * @memberof ProductInput
     */
    props?: object | null;
    /**
     * Tags for the product. This is used for grouping purpose. Eg: [\"gardening\", \"tools\"]
     * @type {Array<string>}
     * @memberof ProductInput
     */
    tags?: Array<string> | null;
    /**
     * 
     * @type {Status}
     * @memberof ProductInput
     */
    status: Status;
    /**
     * List of agent ids which are accessible for this product
     * @type {Array<string>}
     * @memberof ProductInput
     */
    agentIds?: Array<string> | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ProductInputCurrencyEnum {
    AED = 'AED',
    AFN = 'AFN',
    ALL = 'ALL',
    AMD = 'AMD',
    ANG = 'ANG',
    AOA = 'AOA',
    ARS = 'ARS',
    AUD = 'AUD',
    AWG = 'AWG',
    AZN = 'AZN',
    BAM = 'BAM',
    BBD = 'BBD',
    BDT = 'BDT',
    BGN = 'BGN',
    BHD = 'BHD',
    BIF = 'BIF',
    BMD = 'BMD',
    BND = 'BND',
    BOB = 'BOB',
    BOV = 'BOV',
    BRL = 'BRL',
    BSD = 'BSD',
    BTN = 'BTN',
    BWP = 'BWP',
    BYN = 'BYN',
    BZD = 'BZD',
    CAD = 'CAD',
    CDF = 'CDF',
    CHE = 'CHE',
    CHF = 'CHF',
    CHW = 'CHW',
    CLF = 'CLF',
    CLP = 'CLP',
    CNY = 'CNY',
    COP = 'COP',
    COU = 'COU',
    CRC = 'CRC',
    CUC = 'CUC',
    CUP = 'CUP',
    CVE = 'CVE',
    CZK = 'CZK',
    DJF = 'DJF',
    DKK = 'DKK',
    DOP = 'DOP',
    DZD = 'DZD',
    EGP = 'EGP',
    ERN = 'ERN',
    ETB = 'ETB',
    EUR = 'EUR',
    FJD = 'FJD',
    FKP = 'FKP',
    GBP = 'GBP',
    GEL = 'GEL',
    GHS = 'GHS',
    GIP = 'GIP',
    GMD = 'GMD',
    GNF = 'GNF',
    GTQ = 'GTQ',
    GYD = 'GYD',
    HKD = 'HKD',
    HNL = 'HNL',
    HRK = 'HRK',
    HTG = 'HTG',
    HUF = 'HUF',
    IDR = 'IDR',
    ILS = 'ILS',
    INR = 'INR',
    IQD = 'IQD',
    IRR = 'IRR',
    ISK = 'ISK',
    JMD = 'JMD',
    JOD = 'JOD',
    JPY = 'JPY',
    KES = 'KES',
    KGS = 'KGS',
    KHR = 'KHR',
    KMF = 'KMF',
    KPW = 'KPW',
    KRW = 'KRW',
    KWD = 'KWD',
    KYD = 'KYD',
    KZT = 'KZT',
    LAK = 'LAK',
    LBP = 'LBP',
    LKR = 'LKR',
    LRD = 'LRD',
    LSL = 'LSL',
    LYD = 'LYD',
    MAD = 'MAD',
    MDL = 'MDL',
    MGA = 'MGA',
    MKD = 'MKD',
    MMK = 'MMK',
    MNT = 'MNT',
    MOP = 'MOP',
    MRU = 'MRU',
    MUR = 'MUR',
    MVR = 'MVR',
    MWK = 'MWK',
    MXN = 'MXN',
    MXV = 'MXV',
    MYR = 'MYR',
    MZN = 'MZN',
    NAD = 'NAD',
    NGN = 'NGN',
    NIO = 'NIO',
    NOK = 'NOK',
    NPR = 'NPR',
    NZD = 'NZD',
    OMR = 'OMR',
    PAB = 'PAB',
    PEN = 'PEN',
    PGK = 'PGK',
    PHP = 'PHP',
    PKR = 'PKR',
    PLN = 'PLN',
    PYG = 'PYG',
    QAR = 'QAR',
    RON = 'RON',
    RSD = 'RSD',
    RUB = 'RUB',
    RWF = 'RWF',
    SAR = 'SAR',
    SBD = 'SBD',
    SCR = 'SCR',
    SDG = 'SDG',
    SEK = 'SEK',
    SGD = 'SGD',
    SHP = 'SHP',
    SLE = 'SLE',
    SLL = 'SLL',
    SOS = 'SOS',
    SRD = 'SRD',
    SSP = 'SSP',
    STN = 'STN',
    SVC = 'SVC',
    SYP = 'SYP',
    SZL = 'SZL',
    THB = 'THB',
    TJS = 'TJS',
    TMT = 'TMT',
    TND = 'TND',
    TOP = 'TOP',
    TRY = 'TRY',
    TTD = 'TTD',
    TWD = 'TWD',
    TZS = 'TZS',
    UAH = 'UAH',
    UGX = 'UGX',
    USD = 'USD',
    USN = 'USN',
    UYI = 'UYI',
    UYU = 'UYU',
    UYW = 'UYW',
    UZS = 'UZS',
    VED = 'VED',
    VES = 'VES',
    VND = 'VND',
    VUV = 'VUV',
    WST = 'WST',
    XAF = 'XAF',
    XCD = 'XCD',
    XOF = 'XOF',
    XPF = 'XPF',
    XSU = 'XSU',
    XUA = 'XUA',
    YER = 'YER',
    ZAR = 'ZAR',
    ZMW = 'ZMW',
    ZWL = 'ZWL'
}

/**
 * Product and services offered by the business
 * @export
 * @interface ProductOutput
 */
export interface ProductOutput {
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    orgId?: string;
    /**
     * Product is active or not
     * @type {boolean}
     * @memberof ProductOutput
     */
    active?: boolean;
    /**
     * Default price of the product this is represented in the lowest currency denomination. Eg: 1000 for $10
     * @type {number}
     * @memberof ProductOutput
     */
    defaultPrice?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    currency?: string | null;
    /**
     * Description of the product
     * @type {string}
     * @memberof ProductOutput
     */
    description?: string | null;
    /**
     * Name of the product
     * @type {string}
     * @memberof ProductOutput
     */
    name?: string;
    /**
     * Product is shippable or not. Service is not shippable
     * @type {boolean}
     * @memberof ProductOutput
     */
    shippable?: boolean;
    /**
     * List of features of the product
     * @type {Array<string>}
     * @memberof ProductOutput
     */
    features?: Array<string> | null;
    /**
     * Product requires appointment scheduling or not
     * @type {boolean}
     * @memberof ProductOutput
     */
    scheduleAppointment?: boolean;
    /**
     * Properties of the product
     * @type {object}
     * @memberof ProductOutput
     */
    props?: object | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductOutput
     */
    tags?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface ProductWithAgents
 */
export interface ProductWithAgents {
    /**
     * 
     * @type {ProductOutput}
     * @memberof ProductWithAgents
     */
    product: ProductOutput;
    /**
     * 
     * @type {Array<AIAgentOutput>}
     * @memberof ProductWithAgents
     */
    agents?: Array<AIAgentOutput>;
}
/**
 * 
 * @export
 * @interface PromptTemplate
 */
export interface PromptTemplate {
    /**
     * 
     * @type {string}
     * @memberof PromptTemplate
     */
    prompt: string;
    /**
     * 
     * @type {Array<Sequence>}
     * @memberof PromptTemplate
     */
    sequences: Array<Sequence>;
    /**
     * 
     * @type {string}
     * @memberof PromptTemplate
     */
    role: string;
    /**
     * 
     * @type {string}
     * @memberof PromptTemplate
     */
    roleDescription: string;
    /**
     * 
     * @type {string}
     * @memberof PromptTemplate
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ProspectInput
 */
export interface ProspectInput {
    /**
     * Name of the prospect
     * @type {string}
     * @memberof ProspectInput
     */
    name?: string | null;
    /**
     * Email of the prospect
     * @type {string}
     * @memberof ProspectInput
     */
    email?: string | null;
    /**
     * Phone number of the prospect
     * @type {string}
     * @memberof ProspectInput
     */
    phoneNumber?: string | null;
    /**
     * External references for the prospect
     * @type {Array<ExternalReference>}
     * @memberof ProspectInput
     */
    externalReference?: Array<ExternalReference> | null;
    /**
     * 
     * @type {ProspectStatus}
     * @memberof ProspectInput
     */
    status: ProspectStatus;
    /**
     * Props for the prospect
     * @type {object}
     * @memberof ProspectInput
     */
    prospectProps?: object | null;
}
/**
 * Prospects are the potential customers for business
 * @export
 * @interface ProspectOutput
 */
export interface ProspectOutput {
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    email?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    phoneNumber?: string | null;
    /**
     * 
     * @type {Array<ExternalReference>}
     * @memberof ProspectOutput
     */
    externalReference: Array<ExternalReference> | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    status: string;
    /**
     * 
     * @type {object}
     * @memberof ProspectOutput
     */
    prospectProps: object | null;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ProspectOutput
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ProspectStatus {
    NEW = 'NEW',
    GENERALENQUIRY = 'GENERAL_ENQUIRY',
    SCHEDULEDCALLBACKWITHBOT = 'SCHEDULED_CALLBACK_WITH_BOT',
    SCHEDULEDAPPOINTMENTWITHPERSON = 'SCHEDULED_APPOINTMENT_WITH_PERSON',
    SCHEDULEDAPPOINTMENTFORSERVICE = 'SCHEDULED_APPOINTMENT_FOR_SERVICE',
    NOTINTERESTED = 'NOT_INTERESTED',
    PRODUCTORDERPLACED = 'PRODUCT_ORDER_PLACED',
    SERVICEORDERPLACED = 'SERVICE_ORDER_PLACED'
}

/**
 * 
 * @export
 * @interface ResellerBatchMetricsRequests
 */
export interface ResellerBatchMetricsRequests {
    /**
     * 
     * @type {Array<string>}
     * @memberof ResellerBatchMetricsRequests
     */
    organization: Array<string>;
    /**
     * 
     * @type {Array<MetricsRequest>}
     * @memberof ResellerBatchMetricsRequests
     */
    requests: Array<MetricsRequest>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Role {
    ADMIN = 'ADMIN',
    READONLY = 'READ_ONLY',
    RESELLERADMIN = 'RESELLER_ADMIN'
}

/**
 * 
 * @export
 * @interface RoleTemplate
 */
export interface RoleTemplate {
    /**
     * 
     * @type {string}
     * @memberof RoleTemplate
     */
    roleName: string;
    /**
     * 
     * @type {string}
     * @memberof RoleTemplate
     */
    roleDescription: string;
}
/**
 * 
 * @export
 * @interface Sequence
 */
export interface Sequence {
    /**
     * Name of the stage
     * @type {string}
     * @memberof Sequence
     */
    stageName: string;
    /**
     * Description of the stage
     * @type {string}
     * @memberof Sequence
     */
    description: string;
    /**
     * Other notes that AI agent should know in this stage of conversation
     * @type {string}
     * @memberof Sequence
     */
    otherNotes?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SortOrder {
    Asc = 'asc',
    Desc = 'desc'
}

/**
 * 
 * @export
 * @interface StatsData
 */
export interface StatsData {
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    no_of_prospects: number;
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    appointment_scheduled: number;
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    unqualified: number;
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    average_call_duration: number;
}
/**
 * 
 * @export
 * @interface StatsResponse
 */
export interface StatsResponse {
    /**
     * Overall stats of prospects
     * @type {StatsData}
     * @memberof StatsResponse
     */
    response: StatsData;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Status {
    Active = 'active',
    Inactive = 'inactive'
}

/**
 * Subscription details of the business
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    parentOrgId?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    subscriptionTypeName?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    planName?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    priceId?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    stripeSubscriptionId?: string;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    billingCycleStartDate?: number;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    updatedAt?: string;
}
/**
 * Subscription details of the business
 * @export
 * @interface SubscriptionInfo
 */
export interface SubscriptionInfo {
    /**
     * 
     * @type {Subscription}
     * @memberof SubscriptionInfo
     */
    subscription?: Subscription | null;
    /**
     * 
     * @type {Array<Credit>}
     * @memberof SubscriptionInfo
     */
    credits?: Array<Credit> | null;
}
/**
 * 
 * @export
 * @interface TaxDetailsInput
 */
export interface TaxDetailsInput {
    /**
     * Tax identifier
     * @type {string}
     * @memberof TaxDetailsInput
     */
    id: string;
    /**
     * Any extra info related to Tax
     * @type {object}
     * @memberof TaxDetailsInput
     */
    taxProps: object | null;
}
/**
 * 
 * @export
 * @interface TaxDetailsOutput
 */
export interface TaxDetailsOutput {
    /**
     * 
     * @type {string}
     * @memberof TaxDetailsOutput
     */
    id: string;
    /**
     * 
     * @type {object}
     * @memberof TaxDetailsOutput
     */
    taxProps: object | null;
}
/**
 * Telephone number details of the business
 * @export
 * @interface TelephoneNumber
 */
export interface TelephoneNumber {
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    countryCode?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    agentId?: string | null;
    /**
     * 
     * @type {object}
     * @memberof TelephoneNumber
     */
    internalProps?: object | null;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof TelephoneNumber
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface Transcriber
 */
export interface Transcriber {
    /**
     * 
     * @type {string}
     * @memberof Transcriber
     */
    providerName?: string;
    /**
     * 
     * @type {string}
     * @memberof Transcriber
     */
    transcriberModel?: string | null;
    /**
     * 
     * @type {object}
     * @memberof Transcriber
     */
    providerProps?: object | null;
}
/**
 * 
 * @export
 * @interface UpdateResellerOrganizationRequest
 */
export interface UpdateResellerOrganizationRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateResellerOrganizationRequest
     */
    name?: string | null;
    /**
     * 
     * @type {AddressInput}
     * @memberof UpdateResellerOrganizationRequest
     */
    address?: AddressInput | null;
    /**
     * 
     * @type {TaxDetailsInput}
     * @memberof UpdateResellerOrganizationRequest
     */
    tax?: TaxDetailsInput | null;
}
/**
 * Payload for updating user details API
 * @export
 * @interface UpdateUserPayload
 */
export interface UpdateUserPayload {
    /**
     * 
     * @type {Role}
     * @memberof UpdateUserPayload
     */
    role: Role | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserPayload
     */
    fullName: string | null;
}
/**
 * Model representing the users under an organization
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    fullName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    updatedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    updatedAt?: string;
}
/**
 * User id to api key mapping table
 * @export
 * @interface UserApiKeyLink
 */
export interface UserApiKeyLink {
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    secretKey?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    keyType?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApiKeyLink
     */
    expiresAt?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserApiKeyLink
     */
    isActive?: boolean;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string | number>}
     * @memberof ValidationError
     */
    loc: Array<string | number>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface VoiceInput
 */
export interface VoiceInput {
    /**
     * 
     * @type {string}
     * @memberof VoiceInput
     */
    gender: VoiceInputGenderEnum;
    /**
     * 
     * @type {LanguageAccentCombo}
     * @memberof VoiceInput
     */
    languageAccent: LanguageAccentCombo;
    /**
     * 
     * @type {string}
     * @memberof VoiceInput
     */
    modelId: string;
}

/**
    * @export
    * @enum {string}
    */
export enum VoiceInputGenderEnum {
    Male = 'Male',
    Female = 'Female',
    Neutral = 'Neutral'
}

/**
 * 
 * @export
 * @interface VoiceModel
 */
export interface VoiceModel {
    /**
     * 
     * @type {VoiceOutput}
     * @memberof VoiceModel
     */
    voice: VoiceOutput;
    /**
     * 
     * @type {string}
     * @memberof VoiceModel
     */
    previewUrl: string;
    /**
     * 
     * @type {string}
     * @memberof VoiceModel
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof VoiceModel
     */
    voiceDescription: string;
}
/**
 * 
 * @export
 * @interface VoiceOutput
 */
export interface VoiceOutput {
    /**
     * 
     * @type {string}
     * @memberof VoiceOutput
     */
    gender: VoiceOutputGenderEnum;
    /**
     * 
     * @type {LanguageAccentCombo}
     * @memberof VoiceOutput
     */
    languageAccent: LanguageAccentCombo;
    /**
     * 
     * @type {string}
     * @memberof VoiceOutput
     */
    modelId: string;
}

/**
    * @export
    * @enum {string}
    */
export enum VoiceOutputGenderEnum {
    Male = 'Male',
    Female = 'Female',
    Neutral = 'Neutral'
}


/**
 * ActionAgentLinkApi - axios parameter creator
 * @export
 */
export const ActionAgentLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Link Between an Action and an Agent
         * @summary Create a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionAgentLinkV1: async (actionId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new RequiredError('actionId','Required parameter actionId was null or undefined when calling createActionAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling createActionAgentLinkV1.');
            }
            const localVarPath = `/v1/actions/{action_id}/ai-agents/{agent_id}/link`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Link Between an Action and an Agent
         * @summary Delete a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionAgentLinkV1: async (actionId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new RequiredError('actionId','Required parameter actionId was null or undefined when calling deleteActionAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling deleteActionAgentLinkV1.');
            }
            const localVarPath = `/v1/actions/{action_id}/ai-agents/{agent_id}/link`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Actions Linked to a Specific Agent
         * @summary List All Actions Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsOfAgentV1: async (agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling listActionsOfAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}/actions`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionAgentLinkApi - functional programming interface
 * @export
 */
export const ActionAgentLinkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a Link Between an Action and an Agent
         * @summary Create a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActionAgentLinkV1(actionId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await ActionAgentLinkApiAxiosParamCreator(configuration).createActionAgentLinkV1(actionId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Link Between an Action and an Agent
         * @summary Delete a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteActionAgentLinkV1(actionId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await ActionAgentLinkApiAxiosParamCreator(configuration).deleteActionAgentLinkV1(actionId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Actions Linked to a Specific Agent
         * @summary List All Actions Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActionsOfAgentV1(agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActionOutput>>> {
            const localVarAxiosArgs = await ActionAgentLinkApiAxiosParamCreator(configuration).listActionsOfAgentV1(agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ActionAgentLinkApi - factory interface
 * @export
 */
export const ActionAgentLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a Link Between an Action and an Agent
         * @summary Create a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionAgentLinkV1(actionId: string, agentId: string, options?: any): AxiosPromise<BaseResponse> {
            return ActionAgentLinkApiFp(configuration).createActionAgentLinkV1(actionId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Link Between an Action and an Agent
         * @summary Delete a Link Between an Action and an Agent
         * @param {string} actionId ID of the action
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionAgentLinkV1(actionId: string, agentId: string, options?: any): AxiosPromise<BaseResponse> {
            return ActionAgentLinkApiFp(configuration).deleteActionAgentLinkV1(actionId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Actions Linked to a Specific Agent
         * @summary List All Actions Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsOfAgentV1(agentId: string, options?: any): AxiosPromise<Array<ActionOutput>> {
            return ActionAgentLinkApiFp(configuration).listActionsOfAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionAgentLinkApi - object-oriented interface
 * @export
 * @class ActionAgentLinkApi
 * @extends {BaseAPI}
 */
export class ActionAgentLinkApi extends BaseAPI {
    /**
     * Create a Link Between an Action and an Agent
     * @summary Create a Link Between an Action and an Agent
     * @param {string} actionId ID of the action
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    public createActionAgentLinkV1(actionId: string, agentId: string, options?: any) {
        return ActionAgentLinkApiFp(this.configuration).createActionAgentLinkV1(actionId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Link Between an Action and an Agent
     * @summary Delete a Link Between an Action and an Agent
     * @param {string} actionId ID of the action
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    public deleteActionAgentLinkV1(actionId: string, agentId: string, options?: any) {
        return ActionAgentLinkApiFp(this.configuration).deleteActionAgentLinkV1(actionId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Actions Linked to a Specific Agent
     * @summary List All Actions Linked to a Specific Agent
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionAgentLinkApi
     */
    public listActionsOfAgentV1(agentId: string, options?: any) {
        return ActionAgentLinkApiFp(this.configuration).listActionsOfAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a New Action
         * @summary Create a New Action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionV1: async (actionInput: ActionInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionInput' is not null or undefined
            if (actionInput === null || actionInput === undefined) {
                throw new RequiredError('actionInput','Required parameter actionInput was null or undefined when calling createActionV1.');
            }
            const localVarPath = `/v1/actions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof actionInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(actionInput !== undefined ? actionInput : {}) : (actionInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific Action by ID
         * @summary Delete a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionV1: async (actionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new RequiredError('actionId','Required parameter actionId was null or undefined when calling deleteActionV1.');
            }
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific Action by ID
         * @summary Get a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionV1: async (actionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new RequiredError('actionId','Required parameter actionId was null or undefined when calling getActionV1.');
            }
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Actions Under the User&#39;s Organization
         * @summary List All Actions Under the User&#39;s Organization
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/actions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific Action by ID
         * @summary Update a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActionV1: async (actionId: string, actionInput: ActionInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionId' is not null or undefined
            if (actionId === null || actionId === undefined) {
                throw new RequiredError('actionId','Required parameter actionId was null or undefined when calling updateActionV1.');
            }
            // verify required parameter 'actionInput' is not null or undefined
            if (actionInput === null || actionInput === undefined) {
                throw new RequiredError('actionInput','Required parameter actionInput was null or undefined when calling updateActionV1.');
            }
            const localVarPath = `/v1/actions/{action_id}`
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof actionInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(actionInput !== undefined ? actionInput : {}) : (actionInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a New Action
         * @summary Create a New Action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActionV1(actionInput: ActionInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionOutput>> {
            const localVarAxiosArgs = await ActionsApiAxiosParamCreator(configuration).createActionV1(actionInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Specific Action by ID
         * @summary Delete a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteActionV1(actionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await ActionsApiAxiosParamCreator(configuration).deleteActionV1(actionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a Specific Action by ID
         * @summary Get a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActionV1(actionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionOutput>> {
            const localVarAxiosArgs = await ActionsApiAxiosParamCreator(configuration).getActionV1(actionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Actions Under the User&#39;s Organization
         * @summary List All Actions Under the User&#39;s Organization
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActionsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActionOutput>>> {
            const localVarAxiosArgs = await ActionsApiAxiosParamCreator(configuration).listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Specific Action by ID
         * @summary Update a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateActionV1(actionId: string, actionInput: ActionInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionOutput>> {
            const localVarAxiosArgs = await ActionsApiAxiosParamCreator(configuration).updateActionV1(actionId, actionInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a New Action
         * @summary Create a New Action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionV1(actionInput: ActionInput, options?: any): AxiosPromise<ActionOutput> {
            return ActionsApiFp(configuration).createActionV1(actionInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Action by ID
         * @summary Delete a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActionV1(actionId: string, options?: any): AxiosPromise<BaseResponse> {
            return ActionsApiFp(configuration).deleteActionV1(actionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Action by ID
         * @summary Get a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionV1(actionId: string, options?: any): AxiosPromise<ActionOutput> {
            return ActionsApiFp(configuration).getActionV1(actionId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Actions Under the User&#39;s Organization
         * @summary List All Actions Under the User&#39;s Organization
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<ActionOutput>> {
            return ActionsApiFp(configuration).listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Action by ID
         * @summary Update a Specific Action by ID
         * @param {string} actionId ID of the action
         * @param {ActionInput} actionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActionV1(actionId: string, actionInput: ActionInput, options?: any): AxiosPromise<ActionOutput> {
            return ActionsApiFp(configuration).updateActionV1(actionId, actionInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI {
    /**
     * Create a New Action
     * @summary Create a New Action
     * @param {ActionInput} actionInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public createActionV1(actionInput: ActionInput, options?: any) {
        return ActionsApiFp(this.configuration).createActionV1(actionInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific Action by ID
     * @summary Delete a Specific Action by ID
     * @param {string} actionId ID of the action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public deleteActionV1(actionId: string, options?: any) {
        return ActionsApiFp(this.configuration).deleteActionV1(actionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific Action by ID
     * @summary Get a Specific Action by ID
     * @param {string} actionId ID of the action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getActionV1(actionId: string, options?: any) {
        return ActionsApiFp(this.configuration).getActionV1(actionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Actions Under the User&#39;s Organization
     * @summary List All Actions Under the User&#39;s Organization
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public listActionsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return ActionsApiFp(this.configuration).listActionsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific Action by ID
     * @summary Update a Specific Action by ID
     * @param {string} actionId ID of the action
     * @param {ActionInput} actionInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public updateActionV1(actionId: string, actionInput: ActionInput, options?: any) {
        return ActionsApiFp(this.configuration).updateActionV1(actionId, actionInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * AgentsApi - axios parameter creator
 * @export
 */
export const AgentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a New AI Agent
         * @summary Create a New AI Agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAIAgentV1: async (aIAgentInput: AIAgentInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'aIAgentInput' is not null or undefined
            if (aIAgentInput === null || aIAgentInput === undefined) {
                throw new RequiredError('aIAgentInput','Required parameter aIAgentInput was null or undefined when calling createAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof aIAgentInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(aIAgentInput !== undefined ? aIAgentInput : {}) : (aIAgentInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific AI Agent by ID
         * @summary Delete a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAIAgentV1: async (agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling deleteAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific AI Agent by ID
         * @summary Get a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIAgentV1: async (agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling getAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All AI Agents Under the User&#39;s Organization
         * @summary List All AI Agents Under the User&#39;s Organization
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIAgentsV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ai-agents`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific AI Agent by ID
         * @summary Update a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAIAgentV1: async (agentId: string, aIAgentInput: AIAgentInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling updateAIAgentV1.');
            }
            // verify required parameter 'aIAgentInput' is not null or undefined
            if (aIAgentInput === null || aIAgentInput === undefined) {
                throw new RequiredError('aIAgentInput','Required parameter aIAgentInput was null or undefined when calling updateAIAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof aIAgentInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(aIAgentInput !== undefined ? aIAgentInput : {}) : (aIAgentInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentsApi - functional programming interface
 * @export
 */
export const AgentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a New AI Agent
         * @summary Create a New AI Agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAIAgentV1(aIAgentInput: AIAgentInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AIAgentOutput>> {
            const localVarAxiosArgs = await AgentsApiAxiosParamCreator(configuration).createAIAgentV1(aIAgentInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Specific AI Agent by ID
         * @summary Delete a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAIAgentV1(agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await AgentsApiAxiosParamCreator(configuration).deleteAIAgentV1(agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a Specific AI Agent by ID
         * @summary Get a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAIAgentV1(agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AIAgentOutput>> {
            const localVarAxiosArgs = await AgentsApiAxiosParamCreator(configuration).getAIAgentV1(agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All AI Agents Under the User&#39;s Organization
         * @summary List All AI Agents Under the User&#39;s Organization
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAIAgentsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AIAgentOutput>>> {
            const localVarAxiosArgs = await AgentsApiAxiosParamCreator(configuration).listAIAgentsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Specific AI Agent by ID
         * @summary Update a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAIAgentV1(agentId: string, aIAgentInput: AIAgentInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AIAgentOutput>> {
            const localVarAxiosArgs = await AgentsApiAxiosParamCreator(configuration).updateAIAgentV1(agentId, aIAgentInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AgentsApi - factory interface
 * @export
 */
export const AgentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a New AI Agent
         * @summary Create a New AI Agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAIAgentV1(aIAgentInput: AIAgentInput, options?: any): AxiosPromise<AIAgentOutput> {
            return AgentsApiFp(configuration).createAIAgentV1(aIAgentInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific AI Agent by ID
         * @summary Delete a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAIAgentV1(agentId: string, options?: any): AxiosPromise<BaseResponse> {
            return AgentsApiFp(configuration).deleteAIAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific AI Agent by ID
         * @summary Get a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAIAgentV1(agentId: string, options?: any): AxiosPromise<AIAgentOutput> {
            return AgentsApiFp(configuration).getAIAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All AI Agents Under the User&#39;s Organization
         * @summary List All AI Agents Under the User&#39;s Organization
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAIAgentsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<AIAgentOutput>> {
            return AgentsApiFp(configuration).listAIAgentsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific AI Agent by ID
         * @summary Update a Specific AI Agent by ID
         * @param {string} agentId ID of the agent
         * @param {AIAgentInput} aIAgentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAIAgentV1(agentId: string, aIAgentInput: AIAgentInput, options?: any): AxiosPromise<AIAgentOutput> {
            return AgentsApiFp(configuration).updateAIAgentV1(agentId, aIAgentInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AgentsApi - object-oriented interface
 * @export
 * @class AgentsApi
 * @extends {BaseAPI}
 */
export class AgentsApi extends BaseAPI {
    /**
     * Create a New AI Agent
     * @summary Create a New AI Agent
     * @param {AIAgentInput} aIAgentInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public createAIAgentV1(aIAgentInput: AIAgentInput, options?: any) {
        return AgentsApiFp(this.configuration).createAIAgentV1(aIAgentInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific AI Agent by ID
     * @summary Delete a Specific AI Agent by ID
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public deleteAIAgentV1(agentId: string, options?: any) {
        return AgentsApiFp(this.configuration).deleteAIAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific AI Agent by ID
     * @summary Get a Specific AI Agent by ID
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public getAIAgentV1(agentId: string, options?: any) {
        return AgentsApiFp(this.configuration).getAIAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All AI Agents Under the User&#39;s Organization
     * @summary List All AI Agents Under the User&#39;s Organization
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public listAIAgentsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return AgentsApiFp(this.configuration).listAIAgentsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific AI Agent by ID
     * @summary Update a Specific AI Agent by ID
     * @param {string} agentId ID of the agent
     * @param {AIAgentInput} aIAgentInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public updateAIAgentV1(agentId: string, aIAgentInput: AIAgentInput, options?: any) {
        return AgentsApiFp(this.configuration).updateAIAgentV1(agentId, aIAgentInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ApiKeyApi - axios parameter creator
 * @export
 */
export const ApiKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Api Key
         * @param {ApiKeyRequest} apiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyV1: async (apiKeyRequest: ApiKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeyRequest' is not null or undefined
            if (apiKeyRequest === null || apiKeyRequest === undefined) {
                throw new RequiredError('apiKeyRequest','Required parameter apiKeyRequest was null or undefined when calling createApiKeyV1.');
            }
            const localVarPath = `/v1/api-keys`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof apiKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(apiKeyRequest !== undefined ? apiKeyRequest : {}) : (apiKeyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyV1: async (keyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            if (keyId === null || keyId === undefined) {
                throw new RequiredError('keyId','Required parameter keyId was null or undefined when calling deleteApiKeyV1.');
            }
            const localVarPath = `/v1/api-keys/{key_id}`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Call Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallKeyV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/api-keys/call-key`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/api-keys`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeyApi - functional programming interface
 * @export
 */
export const ApiKeyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Api Key
         * @param {ApiKeyRequest} apiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiKeyV1(apiKeyRequest: ApiKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserApiKeyLink>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).createApiKeyV1(apiKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiKeyV1(keyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).deleteApiKeyV1(keyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Call Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCallKeyV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserApiKeyLink>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).getCallKeyV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApiKeysV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserApiKeyLink>>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).listApiKeysV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ApiKeyApi - factory interface
 * @export
 */
export const ApiKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create Api Key
         * @param {ApiKeyRequest} apiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyV1(apiKeyRequest: ApiKeyRequest, options?: any): AxiosPromise<UserApiKeyLink> {
            return ApiKeyApiFp(configuration).createApiKeyV1(apiKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyV1(keyId: string, options?: any): AxiosPromise<BaseResponse> {
            return ApiKeyApiFp(configuration).deleteApiKeyV1(keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Call Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallKeyV1(options?: any): AxiosPromise<UserApiKeyLink> {
            return ApiKeyApiFp(configuration).getCallKeyV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysV1(options?: any): AxiosPromise<Array<UserApiKeyLink>> {
            return ApiKeyApiFp(configuration).listApiKeysV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiKeyApi - object-oriented interface
 * @export
 * @class ApiKeyApi
 * @extends {BaseAPI}
 */
export class ApiKeyApi extends BaseAPI {
    /**
     * 
     * @summary Create Api Key
     * @param {ApiKeyRequest} apiKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public createApiKeyV1(apiKeyRequest: ApiKeyRequest, options?: any) {
        return ApiKeyApiFp(this.configuration).createApiKeyV1(apiKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Api Key
     * @param {string} keyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public deleteApiKeyV1(keyId: string, options?: any) {
        return ApiKeyApiFp(this.configuration).deleteApiKeyV1(keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Call Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public getCallKeyV1(options?: any) {
        return ApiKeyApiFp(this.configuration).getCallKeyV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Api Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public listApiKeysV1(options?: any) {
        return ApiKeyApiFp(this.configuration).listApiKeysV1(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * BillingApi - axios parameter creator
 * @export
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Checkout Session For Billable Product
         * @param {string} billableProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForBillableProductV1: async (billableProductId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'billableProductId' is not null or undefined
            if (billableProductId === null || billableProductId === undefined) {
                throw new RequiredError('billableProductId','Required parameter billableProductId was null or undefined when calling createCheckoutSessionForBillableProductV1.');
            }
            const localVarPath = `/v1/subscription/billable-products/{billable_product_id}/checkout`
                .replace(`{${"billable_product_id"}}`, encodeURIComponent(String(billableProductId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Customer Session Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerSessionSecretV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscription/customer-session-secret`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Subscription Billable Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionBillableProductsV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscription/billable-products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Subscription Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPortalV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscription/portal`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscription`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 * @export
 */
export const BillingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Checkout Session For Billable Product
         * @param {string} billableProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckoutSessionForBillableProductV1(billableProductId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await BillingApiAxiosParamCreator(configuration).createCheckoutSessionForBillableProductV1(billableProductId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Customer Session Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerSessionSecretV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await BillingApiAxiosParamCreator(configuration).getCustomerSessionSecretV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Subscription Billable Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionBillableProductsV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Price>>> {
            const localVarAxiosArgs = await BillingApiAxiosParamCreator(configuration).getSubscriptionBillableProductsV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Subscription Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionPortalV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await BillingApiAxiosParamCreator(configuration).getSubscriptionPortalV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionInfo>> {
            const localVarAxiosArgs = await BillingApiAxiosParamCreator(configuration).getSubscriptionV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BillingApi - factory interface
 * @export
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create Checkout Session For Billable Product
         * @param {string} billableProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSessionForBillableProductV1(billableProductId: string, options?: any): AxiosPromise<string> {
            return BillingApiFp(configuration).createCheckoutSessionForBillableProductV1(billableProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Customer Session Secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerSessionSecretV1(options?: any): AxiosPromise<string> {
            return BillingApiFp(configuration).getCustomerSessionSecretV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Subscription Billable Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionBillableProductsV1(options?: any): AxiosPromise<Array<Price>> {
            return BillingApiFp(configuration).getSubscriptionBillableProductsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Subscription Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPortalV1(options?: any): AxiosPromise<string> {
            return BillingApiFp(configuration).getSubscriptionPortalV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionV1(options?: any): AxiosPromise<SubscriptionInfo> {
            return BillingApiFp(configuration).getSubscriptionV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export class BillingApi extends BaseAPI {
    /**
     * 
     * @summary Create Checkout Session For Billable Product
     * @param {string} billableProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public createCheckoutSessionForBillableProductV1(billableProductId: string, options?: any) {
        return BillingApiFp(this.configuration).createCheckoutSessionForBillableProductV1(billableProductId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Customer Session Secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getCustomerSessionSecretV1(options?: any) {
        return BillingApiFp(this.configuration).getCustomerSessionSecretV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Subscription Billable Products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getSubscriptionBillableProductsV1(options?: any) {
        return BillingApiFp(this.configuration).getSubscriptionBillableProductsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Subscription Portal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getSubscriptionPortalV1(options?: any) {
        return BillingApiFp(this.configuration).getSubscriptionPortalV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getSubscriptionV1(options?: any) {
        return BillingApiFp(this.configuration).getSubscriptionV1(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ConversationProspectLinkApi - axios parameter creator
 * @export
 */
export const ConversationProspectLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a link between a conversation and a prospect
         * @summary Create a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationProspectLinkV1: async (conversationId: string, prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling createConversationProspectLinkV1.');
            }
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling createConversationProspectLinkV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}/prospects/{prospect_id}/links`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a link between a conversation and a prospect
         * @summary Delete a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationProspectLinkV1: async (conversationId: string, prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling deleteConversationProspectLinkV1.');
            }
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling deleteConversationProspectLinkV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}/prospects/{prospect_id}/links`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all conversations linked to a specific prospect
         * @summary List all conversations linked to a specific prospect
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsOfProspectsV1: async (prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling listConversationsOfProspectsV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}/conversations`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversationProspectLinkApi - functional programming interface
 * @export
 */
export const ConversationProspectLinkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a link between a conversation and a prospect
         * @summary Create a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await ConversationProspectLinkApiAxiosParamCreator(configuration).createConversationProspectLinkV1(conversationId, prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a link between a conversation and a prospect
         * @summary Delete a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await ConversationProspectLinkApiAxiosParamCreator(configuration).deleteConversationProspectLinkV1(conversationId, prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all conversations linked to a specific prospect
         * @summary List all conversations linked to a specific prospect
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConversationsOfProspectsV1(prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConversationOutput>>> {
            const localVarAxiosArgs = await ConversationProspectLinkApiAxiosParamCreator(configuration).listConversationsOfProspectsV1(prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ConversationProspectLinkApi - factory interface
 * @export
 */
export const ConversationProspectLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a link between a conversation and a prospect
         * @summary Create a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any): AxiosPromise<BaseResponse> {
            return ConversationProspectLinkApiFp(configuration).createConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a link between a conversation and a prospect
         * @summary Delete a link between a conversation and a prospect
         * @param {string} conversationId ID of the conversation
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any): AxiosPromise<BaseResponse> {
            return ConversationProspectLinkApiFp(configuration).deleteConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all conversations linked to a specific prospect
         * @summary List all conversations linked to a specific prospect
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsOfProspectsV1(prospectId: string, options?: any): AxiosPromise<Array<ConversationOutput>> {
            return ConversationProspectLinkApiFp(configuration).listConversationsOfProspectsV1(prospectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConversationProspectLinkApi - object-oriented interface
 * @export
 * @class ConversationProspectLinkApi
 * @extends {BaseAPI}
 */
export class ConversationProspectLinkApi extends BaseAPI {
    /**
     * Create a link between a conversation and a prospect
     * @summary Create a link between a conversation and a prospect
     * @param {string} conversationId ID of the conversation
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    public createConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any) {
        return ConversationProspectLinkApiFp(this.configuration).createConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a link between a conversation and a prospect
     * @summary Delete a link between a conversation and a prospect
     * @param {string} conversationId ID of the conversation
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    public deleteConversationProspectLinkV1(conversationId: string, prospectId: string, options?: any) {
        return ConversationProspectLinkApiFp(this.configuration).deleteConversationProspectLinkV1(conversationId, prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all conversations linked to a specific prospect
     * @summary List all conversations linked to a specific prospect
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationProspectLinkApi
     */
    public listConversationsOfProspectsV1(prospectId: string, options?: any) {
        return ConversationProspectLinkApiFp(this.configuration).listConversationsOfProspectsV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ConversationsApi - axios parameter creator
 * @export
 */
export const ConversationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add Feedback to a Specific Conversation
         * @summary Add Feedback to a Specific Conversation
         * @param {string} conversationId ID of the conversation
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedbackV1: async (conversationId: string, comment: Comment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling addFeedbackV1.');
            }
            // verify required parameter 'comment' is not null or undefined
            if (comment === null || comment === undefined) {
                throw new RequiredError('comment','Required parameter comment was null or undefined when calling addFeedbackV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}/feedback`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof comment !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(comment !== undefined ? comment : {}) : (comment || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a New Conversation
         * @summary Create a New Conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationV1: async (conversationInput: ConversationInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationInput' is not null or undefined
            if (conversationInput === null || conversationInput === undefined) {
                throw new RequiredError('conversationInput','Required parameter conversationInput was null or undefined when calling createConversationV1.');
            }
            const localVarPath = `/v1/conversations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof conversationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(conversationInput !== undefined ? conversationInput : {}) : (conversationInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific Conversation by ID
         * @summary Delete a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationV1: async (conversationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling deleteConversationV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific Conversation by ID
         * @summary Get a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationV1: async (conversationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling getConversationV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Conversations Under the User&#39;s Organization
         * @summary List All Conversations Under the User&#39;s Organization
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/conversations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific Conversation by ID
         * @summary Update a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationV1: async (conversationId: string, conversationInput: ConversationInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId','Required parameter conversationId was null or undefined when calling updateConversationV1.');
            }
            // verify required parameter 'conversationInput' is not null or undefined
            if (conversationInput === null || conversationInput === undefined) {
                throw new RequiredError('conversationInput','Required parameter conversationInput was null or undefined when calling updateConversationV1.');
            }
            const localVarPath = `/v1/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof conversationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(conversationInput !== undefined ? conversationInput : {}) : (conversationInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversationsApi - functional programming interface
 * @export
 */
export const ConversationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add Feedback to a Specific Conversation
         * @summary Add Feedback to a Specific Conversation
         * @param {string} conversationId ID of the conversation
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFeedbackV1(conversationId: string, comment: Comment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationFeedback>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).addFeedbackV1(conversationId, comment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a New Conversation
         * @summary Create a New Conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConversationV1(conversationInput: ConversationInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationOutput>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).createConversationV1(conversationInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Specific Conversation by ID
         * @summary Delete a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConversationV1(conversationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).deleteConversationV1(conversationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a Specific Conversation by ID
         * @summary Get a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversationV1(conversationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationOutput>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).getConversationV1(conversationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Conversations Under the User&#39;s Organization
         * @summary List All Conversations Under the User&#39;s Organization
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConversationsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConversationOutput>>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).listConversationsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Specific Conversation by ID
         * @summary Update a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConversationV1(conversationId: string, conversationInput: ConversationInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationOutput>> {
            const localVarAxiosArgs = await ConversationsApiAxiosParamCreator(configuration).updateConversationV1(conversationId, conversationInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ConversationsApi - factory interface
 * @export
 */
export const ConversationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Add Feedback to a Specific Conversation
         * @summary Add Feedback to a Specific Conversation
         * @param {string} conversationId ID of the conversation
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeedbackV1(conversationId: string, comment: Comment, options?: any): AxiosPromise<ConversationFeedback> {
            return ConversationsApiFp(configuration).addFeedbackV1(conversationId, comment, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a New Conversation
         * @summary Create a New Conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationV1(conversationInput: ConversationInput, options?: any): AxiosPromise<ConversationOutput> {
            return ConversationsApiFp(configuration).createConversationV1(conversationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Conversation by ID
         * @summary Delete a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationV1(conversationId: string, options?: any): AxiosPromise<BaseResponse> {
            return ConversationsApiFp(configuration).deleteConversationV1(conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Conversation by ID
         * @summary Get a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationV1(conversationId: string, options?: any): AxiosPromise<ConversationOutput> {
            return ConversationsApiFp(configuration).getConversationV1(conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Conversations Under the User&#39;s Organization
         * @summary List All Conversations Under the User&#39;s Organization
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<ConversationOutput>> {
            return ConversationsApiFp(configuration).listConversationsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Conversation by ID
         * @summary Update a Specific Conversation by ID
         * @param {string} conversationId ID of the conversation
         * @param {ConversationInput} conversationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationV1(conversationId: string, conversationInput: ConversationInput, options?: any): AxiosPromise<ConversationOutput> {
            return ConversationsApiFp(configuration).updateConversationV1(conversationId, conversationInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConversationsApi - object-oriented interface
 * @export
 * @class ConversationsApi
 * @extends {BaseAPI}
 */
export class ConversationsApi extends BaseAPI {
    /**
     * Add Feedback to a Specific Conversation
     * @summary Add Feedback to a Specific Conversation
     * @param {string} conversationId ID of the conversation
     * @param {Comment} comment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public addFeedbackV1(conversationId: string, comment: Comment, options?: any) {
        return ConversationsApiFp(this.configuration).addFeedbackV1(conversationId, comment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a New Conversation
     * @summary Create a New Conversation
     * @param {ConversationInput} conversationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public createConversationV1(conversationInput: ConversationInput, options?: any) {
        return ConversationsApiFp(this.configuration).createConversationV1(conversationInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific Conversation by ID
     * @summary Delete a Specific Conversation by ID
     * @param {string} conversationId ID of the conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public deleteConversationV1(conversationId: string, options?: any) {
        return ConversationsApiFp(this.configuration).deleteConversationV1(conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific Conversation by ID
     * @summary Get a Specific Conversation by ID
     * @param {string} conversationId ID of the conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public getConversationV1(conversationId: string, options?: any) {
        return ConversationsApiFp(this.configuration).getConversationV1(conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Conversations Under the User&#39;s Organization
     * @summary List All Conversations Under the User&#39;s Organization
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public listConversationsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return ConversationsApiFp(this.configuration).listConversationsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific Conversation by ID
     * @summary Update a Specific Conversation by ID
     * @param {string} conversationId ID of the conversation
     * @param {ConversationInput} conversationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public updateConversationV1(conversationId: string, conversationInput: ConversationInput, options?: any) {
        return ConversationsApiFp(this.configuration).updateConversationV1(conversationId, conversationInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * DataPlaneApi - axios parameter creator
 * @export
 */
export const DataPlaneApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Createconnection
         * @param {string} agentId 
         * @param {ConnectionSource} connectionSource 
         * @param {string} [prospectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection: async (agentId: string, connectionSource: ConnectionSource, prospectId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling createConnection.');
            }
            // verify required parameter 'connectionSource' is not null or undefined
            if (connectionSource === null || connectionSource === undefined) {
                throw new RequiredError('connectionSource','Required parameter connectionSource was null or undefined when calling createConnection.');
            }
            const localVarPath = `/v1/connections`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (agentId !== undefined) {
                localVarQueryParameter['agentId'] = agentId;
            }

            if (prospectId !== undefined) {
                localVarQueryParameter['prospect_id'] = prospectId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof connectionSource !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(connectionSource !== undefined ? connectionSource : {}) : (connectionSource || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getplivoaudiostreamxml
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlivoAudioStreamXml: async (connectionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            if (connectionId === null || connectionId === undefined) {
                throw new RequiredError('connectionId','Required parameter connectionId was null or undefined when calling getPlivoAudioStreamXml.');
            }
            const localVarPath = `/v1/connections/{connection_id}/plivo-audio-stream-xml`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataPlaneApi - functional programming interface
 * @export
 */
export const DataPlaneApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Createconnection
         * @param {string} agentId 
         * @param {ConnectionSource} connectionSource 
         * @param {string} [prospectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnection(agentId: string, connectionSource: ConnectionSource, prospectId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connection>> {
            const localVarAxiosArgs = await DataPlaneApiAxiosParamCreator(configuration).createConnection(agentId, connectionSource, prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Getplivoaudiostreamxml
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlivoAudioStreamXml(connectionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await DataPlaneApiAxiosParamCreator(configuration).getPlivoAudioStreamXml(connectionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DataPlaneApi - factory interface
 * @export
 */
export const DataPlaneApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Createconnection
         * @param {string} agentId 
         * @param {ConnectionSource} connectionSource 
         * @param {string} [prospectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(agentId: string, connectionSource: ConnectionSource, prospectId?: string, options?: any): AxiosPromise<Connection> {
            return DataPlaneApiFp(configuration).createConnection(agentId, connectionSource, prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getplivoaudiostreamxml
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlivoAudioStreamXml(connectionId: string, options?: any): AxiosPromise<BaseResponse> {
            return DataPlaneApiFp(configuration).getPlivoAudioStreamXml(connectionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataPlaneApi - object-oriented interface
 * @export
 * @class DataPlaneApi
 * @extends {BaseAPI}
 */
export class DataPlaneApi extends BaseAPI {
    /**
     * 
     * @summary Createconnection
     * @param {string} agentId 
     * @param {ConnectionSource} connectionSource 
     * @param {string} [prospectId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPlaneApi
     */
    public createConnection(agentId: string, connectionSource: ConnectionSource, prospectId?: string, options?: any) {
        return DataPlaneApiFp(this.configuration).createConnection(agentId, connectionSource, prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Getplivoaudiostreamxml
     * @param {string} connectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPlaneApi
     */
    public getPlivoAudioStreamXml(connectionId: string, options?: any) {
        return DataPlaneApiFp(this.configuration).getPlivoAudioStreamXml(connectionId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check the health of all Trata APIs
         * @summary Check the Health of All TrataAPI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStatusGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Check the health of all Trata APIs
         * @summary Check the Health of All TrataAPI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusStatusGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await HealthApiAxiosParamCreator(configuration).statusStatusGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Check the health of all Trata APIs
         * @summary Check the Health of All TrataAPI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStatusGet(options?: any): AxiosPromise<object> {
            return HealthApiFp(configuration).statusStatusGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * Check the health of all Trata APIs
     * @summary Check the Health of All TrataAPI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public statusStatusGet(options?: any) {
        return HealthApiFp(this.configuration).statusStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * HiveApi - axios parameter creator
 * @export
 */
export const HiveApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
         * @summary Create a New Hive
         * @param {HiveContentInput} hiveContentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveV1: async (hiveContentInput: HiveContentInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveContentInput' is not null or undefined
            if (hiveContentInput === null || hiveContentInput === undefined) {
                throw new RequiredError('hiveContentInput','Required parameter hiveContentInput was null or undefined when calling createHiveV1.');
            }
            const localVarPath = `/v1/hives`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof hiveContentInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(hiveContentInput !== undefined ? hiveContentInput : {}) : (hiveContentInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific Hive by ID
         * @summary Delete a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveV1: async (hiveId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling deleteHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific Hive by ID
         * @summary Get a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHiveV1: async (hiveId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling getHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Hives Under the User&#39;s Organization
         * @summary List All Hives Under the User&#39;s Organization
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/hives`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific Hive by ID
         * @summary Update a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {HiveContentOutput} hiveContentOutput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHiveV1: async (hiveId: string, hiveContentOutput: HiveContentOutput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling updateHiveV1.');
            }
            // verify required parameter 'hiveContentOutput' is not null or undefined
            if (hiveContentOutput === null || hiveContentOutput === undefined) {
                throw new RequiredError('hiveContentOutput','Required parameter hiveContentOutput was null or undefined when calling updateHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof hiveContentOutput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(hiveContentOutput !== undefined ? hiveContentOutput : {}) : (hiveContentOutput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HiveApi - functional programming interface
 * @export
 */
export const HiveApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
         * @summary Create a New Hive
         * @param {HiveContentInput} hiveContentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHiveV1(hiveContentInput: HiveContentInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hive>> {
            const localVarAxiosArgs = await HiveApiAxiosParamCreator(configuration).createHiveV1(hiveContentInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Specific Hive by ID
         * @summary Delete a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHiveV1(hiveId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await HiveApiAxiosParamCreator(configuration).deleteHiveV1(hiveId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a Specific Hive by ID
         * @summary Get a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHiveV1(hiveId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hive>> {
            const localVarAxiosArgs = await HiveApiAxiosParamCreator(configuration).getHiveV1(hiveId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Hives Under the User&#39;s Organization
         * @summary List All Hives Under the User&#39;s Organization
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHivesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hive>>> {
            const localVarAxiosArgs = await HiveApiAxiosParamCreator(configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Specific Hive by ID
         * @summary Update a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {HiveContentOutput} hiveContentOutput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHiveV1(hiveId: string, hiveContentOutput: HiveContentOutput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hive>> {
            const localVarAxiosArgs = await HiveApiAxiosParamCreator(configuration).updateHiveV1(hiveId, hiveContentOutput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HiveApi - factory interface
 * @export
 */
export const HiveApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
         * @summary Create a New Hive
         * @param {HiveContentInput} hiveContentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveV1(hiveContentInput: HiveContentInput, options?: any): AxiosPromise<Hive> {
            return HiveApiFp(configuration).createHiveV1(hiveContentInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Hive by ID
         * @summary Delete a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveV1(hiveId: string, options?: any): AxiosPromise<BaseResponse> {
            return HiveApiFp(configuration).deleteHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Hive by ID
         * @summary Get a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHiveV1(hiveId: string, options?: any): AxiosPromise<Hive> {
            return HiveApiFp(configuration).getHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Hives Under the User&#39;s Organization
         * @summary List All Hives Under the User&#39;s Organization
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<Hive>> {
            return HiveApiFp(configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Hive by ID
         * @summary Update a Specific Hive by ID
         * @param {string} hiveId ID of the hive
         * @param {HiveContentOutput} hiveContentOutput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHiveV1(hiveId: string, hiveContentOutput: HiveContentOutput, options?: any): AxiosPromise<Hive> {
            return HiveApiFp(configuration).updateHiveV1(hiveId, hiveContentOutput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HiveApi - object-oriented interface
 * @export
 * @class HiveApi
 * @extends {BaseAPI}
 */
export class HiveApi extends BaseAPI {
    /**
     * Hive is a collection of documents that are used to train the Agent. Hive can be a PDF, DOCX, TXT or a website URL
     * @summary Create a New Hive
     * @param {HiveContentInput} hiveContentInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public createHiveV1(hiveContentInput: HiveContentInput, options?: any) {
        return HiveApiFp(this.configuration).createHiveV1(hiveContentInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific Hive by ID
     * @summary Delete a Specific Hive by ID
     * @param {string} hiveId ID of the hive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public deleteHiveV1(hiveId: string, options?: any) {
        return HiveApiFp(this.configuration).deleteHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific Hive by ID
     * @summary Get a Specific Hive by ID
     * @param {string} hiveId ID of the hive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public getHiveV1(hiveId: string, options?: any) {
        return HiveApiFp(this.configuration).getHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Hives Under the User&#39;s Organization
     * @summary List All Hives Under the User&#39;s Organization
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public listHivesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return HiveApiFp(this.configuration).listHivesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific Hive by ID
     * @summary Update a Specific Hive by ID
     * @param {string} hiveId ID of the hive
     * @param {HiveContentOutput} hiveContentOutput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveApi
     */
    public updateHiveV1(hiveId: string, hiveContentOutput: HiveContentOutput, options?: any) {
        return HiveApiFp(this.configuration).updateHiveV1(hiveId, hiveContentOutput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * HiveAgentLinkApi - axios parameter creator
 * @export
 */
export const HiveAgentLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Link Between a Hive and an Agent
         * @summary Create a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveAgentLinkV1: async (hiveId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling createHiveAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling createHiveAgentLinkV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}/ai-agents/{agent_id}/link`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Link Between a Hive and an Agent
         * @summary Delete a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveAgentLinkV1: async (hiveId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling deleteHiveAgentLinkV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling deleteHiveAgentLinkV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}/ai-agents/{agent_id}/link`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Agents Linked to a Specific Hive
         * @summary List All Agents Linked to a Specific Hive
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfHiveV1: async (hiveId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hiveId' is not null or undefined
            if (hiveId === null || hiveId === undefined) {
                throw new RequiredError('hiveId','Required parameter hiveId was null or undefined when calling listAgentsOfHiveV1.');
            }
            const localVarPath = `/v1/hives/{hive_id}/ai-agents`
                .replace(`{${"hive_id"}}`, encodeURIComponent(String(hiveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Hives Linked to a Specific Agent
         * @summary List All Hives Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesOfAgentV1: async (agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling listHivesOfAgentV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}/hives`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HiveAgentLinkApi - functional programming interface
 * @export
 */
export const HiveAgentLinkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a Link Between a Hive and an Agent
         * @summary Create a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHiveAgentLinkV1(hiveId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await HiveAgentLinkApiAxiosParamCreator(configuration).createHiveAgentLinkV1(hiveId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Link Between a Hive and an Agent
         * @summary Delete a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHiveAgentLinkV1(hiveId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await HiveAgentLinkApiAxiosParamCreator(configuration).deleteHiveAgentLinkV1(hiveId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Agents Linked to a Specific Hive
         * @summary List All Agents Linked to a Specific Hive
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAgentsOfHiveV1(hiveId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AIAgentOutput>>> {
            const localVarAxiosArgs = await HiveAgentLinkApiAxiosParamCreator(configuration).listAgentsOfHiveV1(hiveId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Hives Linked to a Specific Agent
         * @summary List All Hives Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHivesOfAgentV1(agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hive>>> {
            const localVarAxiosArgs = await HiveAgentLinkApiAxiosParamCreator(configuration).listHivesOfAgentV1(agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HiveAgentLinkApi - factory interface
 * @export
 */
export const HiveAgentLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a Link Between a Hive and an Agent
         * @summary Create a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHiveAgentLinkV1(hiveId: string, agentId: string, options?: any): AxiosPromise<BaseResponse> {
            return HiveAgentLinkApiFp(configuration).createHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Link Between a Hive and an Agent
         * @summary Delete a Link Between a Hive and an Agent
         * @param {string} hiveId ID of the hive
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHiveAgentLinkV1(hiveId: string, agentId: string, options?: any): AxiosPromise<BaseResponse> {
            return HiveAgentLinkApiFp(configuration).deleteHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Agents Linked to a Specific Hive
         * @summary List All Agents Linked to a Specific Hive
         * @param {string} hiveId ID of the hive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfHiveV1(hiveId: string, options?: any): AxiosPromise<Array<AIAgentOutput>> {
            return HiveAgentLinkApiFp(configuration).listAgentsOfHiveV1(hiveId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Hives Linked to a Specific Agent
         * @summary List All Hives Linked to a Specific Agent
         * @param {string} agentId ID of the agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHivesOfAgentV1(agentId: string, options?: any): AxiosPromise<Array<Hive>> {
            return HiveAgentLinkApiFp(configuration).listHivesOfAgentV1(agentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HiveAgentLinkApi - object-oriented interface
 * @export
 * @class HiveAgentLinkApi
 * @extends {BaseAPI}
 */
export class HiveAgentLinkApi extends BaseAPI {
    /**
     * Create a Link Between a Hive and an Agent
     * @summary Create a Link Between a Hive and an Agent
     * @param {string} hiveId ID of the hive
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    public createHiveAgentLinkV1(hiveId: string, agentId: string, options?: any) {
        return HiveAgentLinkApiFp(this.configuration).createHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Link Between a Hive and an Agent
     * @summary Delete a Link Between a Hive and an Agent
     * @param {string} hiveId ID of the hive
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    public deleteHiveAgentLinkV1(hiveId: string, agentId: string, options?: any) {
        return HiveAgentLinkApiFp(this.configuration).deleteHiveAgentLinkV1(hiveId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Agents Linked to a Specific Hive
     * @summary List All Agents Linked to a Specific Hive
     * @param {string} hiveId ID of the hive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    public listAgentsOfHiveV1(hiveId: string, options?: any) {
        return HiveAgentLinkApiFp(this.configuration).listAgentsOfHiveV1(hiveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Hives Linked to a Specific Agent
     * @summary List All Hives Linked to a Specific Agent
     * @param {string} agentId ID of the agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HiveAgentLinkApi
     */
    public listHivesOfAgentV1(agentId: string, options?: any) {
        return HiveAgentLinkApiFp(this.configuration).listHivesOfAgentV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * InternalApi - axios parameter creator
 * @export
 */
export const InternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInviteV1: async (acceptInviteRequest: AcceptInviteRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'acceptInviteRequest' is not null or undefined
            if (acceptInviteRequest === null || acceptInviteRequest === undefined) {
                throw new RequiredError('acceptInviteRequest','Required parameter acceptInviteRequest was null or undefined when calling acceptInviteV1.');
            }
            const localVarPath = `/v1/invites/accept`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof acceptInviteRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(acceptInviteRequest !== undefined ? acceptInviteRequest : {}) : (acceptInviteRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationV1: async (bodyCreateOrganizationV1: BodyCreateOrganizationV1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateOrganizationV1' is not null or undefined
            if (bodyCreateOrganizationV1 === null || bodyCreateOrganizationV1 === undefined) {
                throw new RequiredError('bodyCreateOrganizationV1','Required parameter bodyCreateOrganizationV1 was null or undefined when calling createOrganizationV1.');
            }
            const localVarPath = `/v1/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyCreateOrganizationV1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyCreateOrganizationV1 !== undefined ? bodyCreateOrganizationV1 : {}) : (bodyCreateOrganizationV1 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete File
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1: async (fileIds: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileIds' is not null or undefined
            if (fileIds === null || fileIds === undefined) {
                throw new RequiredError('fileIds','Required parameter fileIds was null or undefined when calling deleteFileV1.');
            }
            const localVarPath = `/v1/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (fileIds !== undefined) {
                localVarQueryParameter['file_ids'] = fileIds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUserV1.');
            }
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/invites`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInviteV1: async (guestInput: GuestInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guestInput' is not null or undefined
            if (guestInput === null || guestInput === undefined) {
                throw new RequiredError('guestInput','Required parameter guestInput was null or undefined when calling sendInviteV1.');
            }
            const localVarPath = `/v1/invites`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof guestInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(guestInput !== undefined ? guestInput : {}) : (guestInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updateorganization
         * @param {string} orgId ID of the organization
         * @param {OrganizationInput} organizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationV1: async (orgId: string, organizationInput: OrganizationInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            if (orgId === null || orgId === undefined) {
                throw new RequiredError('orgId','Required parameter orgId was null or undefined when calling updateOrganizationV1.');
            }
            // verify required parameter 'organizationInput' is not null or undefined
            if (organizationInput === null || organizationInput === undefined) {
                throw new RequiredError('organizationInput','Required parameter organizationInput was null or undefined when calling updateOrganizationV1.');
            }
            const localVarPath = `/v1/organizations/{org_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof organizationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(organizationInput !== undefined ? organizationInput : {}) : (organizationInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId 
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserV1: async (userId: string, updateUserPayload: UpdateUserPayload, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserV1.');
            }
            // verify required parameter 'updateUserPayload' is not null or undefined
            if (updateUserPayload === null || updateUserPayload === undefined) {
                throw new RequiredError('updateUserPayload','Required parameter updateUserPayload was null or undefined when calling updateUserV1.');
            }
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateUserPayload !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateUserPayload !== undefined ? updateUserPayload : {}) : (updateUserPayload || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload File
         * @param {Array<any>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1: async (files: Array<any>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'files' is not null or undefined
            if (files === null || files === undefined) {
                throw new RequiredError('files','Required parameter files was null or undefined when calling uploadFileV1.');
            }
            const localVarPath = `/v1/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (files) {
            
                localVarFormParams.append('files', files.join(COLLECTION_FORMATS.csv));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalApi - functional programming interface
 * @export
 */
export const InternalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInviteV1(acceptInviteRequest: AcceptInviteRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).acceptInviteV1(acceptInviteRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationV1(bodyCreateOrganizationV1: BodyCreateOrganizationV1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).createOrganizationV1(bodyCreateOrganizationV1, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete File
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFileV1(fileIds: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).deleteFileV1(fileIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).deleteOrganizationV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserV1(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).deleteUserV1(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationOutput>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).getOrganizationV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInvitesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuestOutput>>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsersV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).listUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendInviteV1(guestInput: GuestInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuestOutput>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).sendInviteV1(guestInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updateorganization
         * @param {string} orgId ID of the organization
         * @param {OrganizationInput} organizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationV1(orgId: string, organizationInput: OrganizationInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationOutput>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).updateOrganizationV1(orgId, organizationInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId 
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserV1(userId: string, updateUserPayload: UpdateUserPayload, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).updateUserV1(userId, updateUserPayload, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Upload File
         * @param {Array<any>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileV1(files: Array<any>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Files>>> {
            const localVarAxiosArgs = await InternalApiAxiosParamCreator(configuration).uploadFileV1(files, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InternalApi - factory interface
 * @export
 */
export const InternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Acceptinvite
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInviteV1(acceptInviteRequest: AcceptInviteRequest, options?: any): AxiosPromise<User> {
            return InternalApiFp(configuration).acceptInviteV1(acceptInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new organization and adds the user as the \"ADMIN\" user for the org
         * @summary Createorganization
         * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationV1(bodyCreateOrganizationV1: BodyCreateOrganizationV1, options?: any): AxiosPromise<User> {
            return InternalApiFp(configuration).createOrganizationV1(bodyCreateOrganizationV1, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete File
         * @param {string} fileIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileV1(fileIds: string, options?: any): AxiosPromise<boolean> {
            return InternalApiFp(configuration).deleteFileV1(fileIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deleteorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationV1(options?: any): AxiosPromise<BaseResponse> {
            return InternalApiFp(configuration).deleteOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user
         * @summary Deleteuser
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1(userId: string, options?: any): AxiosPromise<User> {
            return InternalApiFp(configuration).deleteUserV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getorganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationV1(options?: any): AxiosPromise<OrganizationOutput> {
            return InternalApiFp(configuration).getOrganizationV1(options).then((request) => request(axios, basePath));
        },
        /**
         * List of all open invites from the organization
         * @summary Listinvites
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<GuestOutput>> {
            return InternalApiFp(configuration).listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all users under the user\'s organization
         * @summary Listusers
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return InternalApiFp(configuration).listUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Inviteusers
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInviteV1(guestInput: GuestInput, options?: any): AxiosPromise<GuestOutput> {
            return InternalApiFp(configuration).sendInviteV1(guestInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updateorganization
         * @param {string} orgId ID of the organization
         * @param {OrganizationInput} organizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationV1(orgId: string, organizationInput: OrganizationInput, options?: any): AxiosPromise<OrganizationOutput> {
            return InternalApiFp(configuration).updateOrganizationV1(orgId, organizationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user details
         * @summary Updateuser
         * @param {string} userId 
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserV1(userId: string, updateUserPayload: UpdateUserPayload, options?: any): AxiosPromise<User> {
            return InternalApiFp(configuration).updateUserV1(userId, updateUserPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload File
         * @param {Array<any>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileV1(files: Array<any>, options?: any): AxiosPromise<Array<Files>> {
            return InternalApiFp(configuration).uploadFileV1(files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
export class InternalApi extends BaseAPI {
    /**
     * Accept invite and add new user to organization
     * @summary Acceptinvite
     * @param {AcceptInviteRequest} acceptInviteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public acceptInviteV1(acceptInviteRequest: AcceptInviteRequest, options?: any) {
        return InternalApiFp(this.configuration).acceptInviteV1(acceptInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new organization and adds the user as the \"ADMIN\" user for the org
     * @summary Createorganization
     * @param {BodyCreateOrganizationV1} bodyCreateOrganizationV1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public createOrganizationV1(bodyCreateOrganizationV1: BodyCreateOrganizationV1, options?: any) {
        return InternalApiFp(this.configuration).createOrganizationV1(bodyCreateOrganizationV1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete File
     * @param {string} fileIds 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public deleteFileV1(fileIds: string, options?: any) {
        return InternalApiFp(this.configuration).deleteFileV1(fileIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deleteorganization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public deleteOrganizationV1(options?: any) {
        return InternalApiFp(this.configuration).deleteOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user
     * @summary Deleteuser
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public deleteUserV1(userId: string, options?: any) {
        return InternalApiFp(this.configuration).deleteUserV1(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Getorganization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getOrganizationV1(options?: any) {
        return InternalApiFp(this.configuration).getOrganizationV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of all open invites from the organization
     * @summary Listinvites
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public listInvitesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return InternalApiFp(this.configuration).listInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all users under the user\'s organization
     * @summary Listusers
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public listUsersV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return InternalApiFp(this.configuration).listUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a new user to an organization or resend invite to the user if the user is already invited
     * @summary Inviteusers
     * @param {GuestInput} guestInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public sendInviteV1(guestInput: GuestInput, options?: any) {
        return InternalApiFp(this.configuration).sendInviteV1(guestInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updateorganization
     * @param {string} orgId ID of the organization
     * @param {OrganizationInput} organizationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public updateOrganizationV1(orgId: string, organizationInput: OrganizationInput, options?: any) {
        return InternalApiFp(this.configuration).updateOrganizationV1(orgId, organizationInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user details
     * @summary Updateuser
     * @param {string} userId 
     * @param {UpdateUserPayload} updateUserPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public updateUserV1(userId: string, updateUserPayload: UpdateUserPayload, options?: any) {
        return InternalApiFp(this.configuration).updateUserV1(userId, updateUserPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload File
     * @param {Array<any>} files 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public uploadFileV1(files: Array<any>, options?: any) {
        return InternalApiFp(this.configuration).uploadFileV1(files, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get call and other analytics data from Trata AI
         * @summary Getmetrics
         * @param {BatchMetricsRequests} batchMetricsRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1MetricsPost: async (batchMetricsRequests: BatchMetricsRequests, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchMetricsRequests' is not null or undefined
            if (batchMetricsRequests === null || batchMetricsRequests === undefined) {
                throw new RequiredError('batchMetricsRequests','Required parameter batchMetricsRequests was null or undefined when calling getMetricsV1MetricsPost.');
            }
            const localVarPath = `/v1/metrics`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof batchMetricsRequests !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(batchMetricsRequests !== undefined ? batchMetricsRequests : {}) : (batchMetricsRequests || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get overall call stats and prospect stats data from Trata AI
         * @summary Getoverallstats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallStatsV1StatsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/stats`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get call and other analytics data from Trata AI
         * @summary Getmetrics
         * @param {BatchMetricsRequests} batchMetricsRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetricsV1MetricsPost(batchMetricsRequests: BatchMetricsRequests, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchMetricsResponse>> {
            const localVarAxiosArgs = await MetricsApiAxiosParamCreator(configuration).getMetricsV1MetricsPost(batchMetricsRequests, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get overall call stats and prospect stats data from Trata AI
         * @summary Getoverallstats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOverallStatsV1StatsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsResponse>> {
            const localVarAxiosArgs = await MetricsApiAxiosParamCreator(configuration).getOverallStatsV1StatsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get call and other analytics data from Trata AI
         * @summary Getmetrics
         * @param {BatchMetricsRequests} batchMetricsRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1MetricsPost(batchMetricsRequests: BatchMetricsRequests, options?: any): AxiosPromise<BatchMetricsResponse> {
            return MetricsApiFp(configuration).getMetricsV1MetricsPost(batchMetricsRequests, options).then((request) => request(axios, basePath));
        },
        /**
         * Get overall call stats and prospect stats data from Trata AI
         * @summary Getoverallstats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverallStatsV1StatsGet(options?: any): AxiosPromise<StatsResponse> {
            return MetricsApiFp(configuration).getOverallStatsV1StatsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * Get call and other analytics data from Trata AI
     * @summary Getmetrics
     * @param {BatchMetricsRequests} batchMetricsRequests 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetricsV1MetricsPost(batchMetricsRequests: BatchMetricsRequests, options?: any) {
        return MetricsApiFp(this.configuration).getMetricsV1MetricsPost(batchMetricsRequests, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get overall call stats and prospect stats data from Trata AI
     * @summary Getoverallstats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getOverallStatsV1StatsGet(options?: any) {
        return MetricsApiFp(this.configuration).getOverallStatsV1StatsGet(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a New Product
         * @summary Create a New Product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductV1: async (productInput: ProductInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productInput' is not null or undefined
            if (productInput === null || productInput === undefined) {
                throw new RequiredError('productInput','Required parameter productInput was null or undefined when calling createProductV1.');
            }
            const localVarPath = `/v1/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof productInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(productInput !== undefined ? productInput : {}) : (productInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific Product by ID
         * @summary Delete a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductV1: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific Product by ID
         * @summary Get a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductV1: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Agents Linked to a Specific Product
         * @summary List All Agents Linked to a Specific Product
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfProductV1: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling listAgentsOfProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}/agents`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Products Under the User&#39;s Organization
         * @summary List All Products Under the User&#39;s Organization
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {Array<string>} [tags] Filter products by specific tags
         * @param {Array<string>} [productIds] Filter by specific product IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (productIds) {
                localVarQueryParameter['product_ids'] = productIds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific Product by ID
         * @summary Update a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductV1: async (productId: string, productInput: ProductInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling updateProductV1.');
            }
            // verify required parameter 'productInput' is not null or undefined
            if (productInput === null || productInput === undefined) {
                throw new RequiredError('productInput','Required parameter productInput was null or undefined when calling updateProductV1.');
            }
            const localVarPath = `/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof productInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(productInput !== undefined ? productInput : {}) : (productInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a New Product
         * @summary Create a New Product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProductV1(productInput: ProductInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductOutput>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).createProductV1(productInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Specific Product by ID
         * @summary Delete a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductV1(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).deleteProductV1(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a Specific Product by ID
         * @summary Get a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductV1(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductOutput>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).getProductV1(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Agents Linked to a Specific Product
         * @summary List All Agents Linked to a Specific Product
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAgentsOfProductV1(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AIAgentOutput>>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).listAgentsOfProductV1(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Products Under the User&#39;s Organization
         * @summary List All Products Under the User&#39;s Organization
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {Array<string>} [tags] Filter products by specific tags
         * @param {Array<string>} [productIds] Filter by specific product IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProductsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductOutput>>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Specific Product by ID
         * @summary Update a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProductV1(productId: string, productInput: ProductInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductOutput>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).updateProductV1(productId, productInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a New Product
         * @summary Create a New Product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductV1(productInput: ProductInput, options?: any): AxiosPromise<ProductOutput> {
            return ProductsApiFp(configuration).createProductV1(productInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Product by ID
         * @summary Delete a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductV1(productId: string, options?: any): AxiosPromise<BaseResponse> {
            return ProductsApiFp(configuration).deleteProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Product by ID
         * @summary Get a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductV1(productId: string, options?: any): AxiosPromise<ProductOutput> {
            return ProductsApiFp(configuration).getProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Agents Linked to a Specific Product
         * @summary List All Agents Linked to a Specific Product
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsOfProductV1(productId: string, options?: any): AxiosPromise<Array<AIAgentOutput>> {
            return ProductsApiFp(configuration).listAgentsOfProductV1(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Products Under the User&#39;s Organization
         * @summary List All Products Under the User&#39;s Organization
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {Array<string>} [tags] Filter products by specific tags
         * @param {Array<string>} [productIds] Filter by specific product IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options?: any): AxiosPromise<Array<ProductOutput>> {
            return ProductsApiFp(configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Product by ID
         * @summary Update a Specific Product by ID
         * @param {string} productId ID of the product
         * @param {ProductInput} productInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductV1(productId: string, productInput: ProductInput, options?: any): AxiosPromise<ProductOutput> {
            return ProductsApiFp(configuration).updateProductV1(productId, productInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * Create a New Product
     * @summary Create a New Product
     * @param {ProductInput} productInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public createProductV1(productInput: ProductInput, options?: any) {
        return ProductsApiFp(this.configuration).createProductV1(productInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific Product by ID
     * @summary Delete a Specific Product by ID
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProductV1(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).deleteProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific Product by ID
     * @summary Get a Specific Product by ID
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductV1(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).getProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Agents Linked to a Specific Product
     * @summary List All Agents Linked to a Specific Product
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public listAgentsOfProductV1(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).listAgentsOfProductV1(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Products Under the User&#39;s Organization
     * @summary List All Products Under the User&#39;s Organization
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {Array<string>} [tags] Filter products by specific tags
     * @param {Array<string>} [productIds] Filter by specific product IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public listProductsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options?: any) {
        return ProductsApiFp(this.configuration).listProductsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific Product by ID
     * @summary Update a Specific Product by ID
     * @param {string} productId ID of the product
     * @param {ProductInput} productInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProductV1(productId: string, productInput: ProductInput, options?: any) {
        return ProductsApiFp(this.configuration).updateProductV1(productId, productInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ProspectsApi - axios parameter creator
 * @export
 */
export const ProspectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a New Prospect
         * @summary Create a New Prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProspectV1: async (prospectInput: ProspectInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectInput' is not null or undefined
            if (prospectInput === null || prospectInput === undefined) {
                throw new RequiredError('prospectInput','Required parameter prospectInput was null or undefined when calling createProspectV1.');
            }
            const localVarPath = `/v1/prospects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof prospectInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(prospectInput !== undefined ? prospectInput : {}) : (prospectInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Specific Prospect by ID
         * @summary Delete a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProspectV1: async (prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling deleteProspectV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific Prospect by ID
         * @summary Get a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProspectV1: async (prospectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling getProspectV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List All Prospects Under the User&#39;s Organization
         * @summary List All Prospects Under the User&#39;s Organization
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProspectsV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/prospects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Specific Prospect by ID
         * @summary Update a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProspectV1: async (prospectId: string, prospectInput: ProspectInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'prospectId' is not null or undefined
            if (prospectId === null || prospectId === undefined) {
                throw new RequiredError('prospectId','Required parameter prospectId was null or undefined when calling updateProspectV1.');
            }
            // verify required parameter 'prospectInput' is not null or undefined
            if (prospectInput === null || prospectInput === undefined) {
                throw new RequiredError('prospectInput','Required parameter prospectInput was null or undefined when calling updateProspectV1.');
            }
            const localVarPath = `/v1/prospects/{prospect_id}`
                .replace(`{${"prospect_id"}}`, encodeURIComponent(String(prospectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof prospectInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(prospectInput !== undefined ? prospectInput : {}) : (prospectInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProspectsApi - functional programming interface
 * @export
 */
export const ProspectsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a New Prospect
         * @summary Create a New Prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProspectV1(prospectInput: ProspectInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProspectOutput>> {
            const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(configuration).createProspectV1(prospectInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Specific Prospect by ID
         * @summary Delete a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProspectV1(prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(configuration).deleteProspectV1(prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a Specific Prospect by ID
         * @summary Get a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProspectV1(prospectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProspectOutput>> {
            const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(configuration).getProspectV1(prospectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List All Prospects Under the User&#39;s Organization
         * @summary List All Prospects Under the User&#39;s Organization
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProspectsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProspectOutput>>> {
            const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(configuration).listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Specific Prospect by ID
         * @summary Update a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProspectV1(prospectId: string, prospectInput: ProspectInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProspectOutput>> {
            const localVarAxiosArgs = await ProspectsApiAxiosParamCreator(configuration).updateProspectV1(prospectId, prospectInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProspectsApi - factory interface
 * @export
 */
export const ProspectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a New Prospect
         * @summary Create a New Prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProspectV1(prospectInput: ProspectInput, options?: any): AxiosPromise<ProspectOutput> {
            return ProspectsApiFp(configuration).createProspectV1(prospectInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Specific Prospect by ID
         * @summary Delete a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProspectV1(prospectId: string, options?: any): AxiosPromise<BaseResponse> {
            return ProspectsApiFp(configuration).deleteProspectV1(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Prospect by ID
         * @summary Get a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProspectV1(prospectId: string, options?: any): AxiosPromise<ProspectOutput> {
            return ProspectsApiFp(configuration).getProspectV1(prospectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List All Prospects Under the User&#39;s Organization
         * @summary List All Prospects Under the User&#39;s Organization
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProspectsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<ProspectOutput>> {
            return ProspectsApiFp(configuration).listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Specific Prospect by ID
         * @summary Update a Specific Prospect by ID
         * @param {string} prospectId ID of the prospect
         * @param {ProspectInput} prospectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProspectV1(prospectId: string, prospectInput: ProspectInput, options?: any): AxiosPromise<ProspectOutput> {
            return ProspectsApiFp(configuration).updateProspectV1(prospectId, prospectInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProspectsApi - object-oriented interface
 * @export
 * @class ProspectsApi
 * @extends {BaseAPI}
 */
export class ProspectsApi extends BaseAPI {
    /**
     * Create a New Prospect
     * @summary Create a New Prospect
     * @param {ProspectInput} prospectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public createProspectV1(prospectInput: ProspectInput, options?: any) {
        return ProspectsApiFp(this.configuration).createProspectV1(prospectInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Specific Prospect by ID
     * @summary Delete a Specific Prospect by ID
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public deleteProspectV1(prospectId: string, options?: any) {
        return ProspectsApiFp(this.configuration).deleteProspectV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific Prospect by ID
     * @summary Get a Specific Prospect by ID
     * @param {string} prospectId ID of the prospect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public getProspectV1(prospectId: string, options?: any) {
        return ProspectsApiFp(this.configuration).getProspectV1(prospectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List All Prospects Under the User&#39;s Organization
     * @summary List All Prospects Under the User&#39;s Organization
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public listProspectsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return ProspectsApiFp(this.configuration).listProspectsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Specific Prospect by ID
     * @summary Update a Specific Prospect by ID
     * @param {string} prospectId ID of the prospect
     * @param {ProspectInput} prospectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProspectsApi
     */
    public updateProspectV1(prospectId: string, prospectInput: ProspectInput, options?: any) {
        return ProspectsApiFp(this.configuration).updateProspectV1(prospectId, prospectInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ResellerApi - axios parameter creator
 * @export
 */
export const ResellerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Accept Invite
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptResellerUserInviteV1: async (acceptInviteRequest: AcceptInviteRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'acceptInviteRequest' is not null or undefined
            if (acceptInviteRequest === null || acceptInviteRequest === undefined) {
                throw new RequiredError('acceptInviteRequest','Required parameter acceptInviteRequest was null or undefined when calling acceptResellerUserInviteV1.');
            }
            const localVarPath = `/v1/resellers/invites/accept`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof acceptInviteRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(acceptInviteRequest !== undefined ? acceptInviteRequest : {}) : (acceptInviteRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add customer credit
         * @summary Add Customer Credit
         * @param {string} customerOrgId 
         * @param {Array<CustomerCreditRequest>} customerCreditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCustomerCreditV1: async (customerOrgId: string, customerCreditRequest: Array<CustomerCreditRequest>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling addCustomerCreditV1.');
            }
            // verify required parameter 'customerCreditRequest' is not null or undefined
            if (customerCreditRequest === null || customerCreditRequest === undefined) {
                throw new RequiredError('customerCreditRequest','Required parameter customerCreditRequest was null or undefined when calling addCustomerCreditV1.');
            }
            const localVarPath = `/v1/resellers/customer/{customer_org_id}/credits`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof customerCreditRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(customerCreditRequest !== undefined ? customerCreditRequest : {}) : (customerCreditRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add Reseller settings
         * @summary Organization Settings
         * @param {OrganizationSettings} organizationSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResellerSettingsV1: async (organizationSettings: OrganizationSettings, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSettings' is not null or undefined
            if (organizationSettings === null || organizationSettings === undefined) {
                throw new RequiredError('organizationSettings','Required parameter organizationSettings was null or undefined when calling addResellerSettingsV1.');
            }
            const localVarPath = `/v1/resellers/settings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof organizationSettings !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(organizationSettings !== undefined ? organizationSettings : {}) : (organizationSettings || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new customer organization under a reseller organization
         * @summary Create Customer
         * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerOrganizationV1: async (bodyCreateCustomerOrganizationV1: BodyCreateCustomerOrganizationV1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateCustomerOrganizationV1' is not null or undefined
            if (bodyCreateCustomerOrganizationV1 === null || bodyCreateCustomerOrganizationV1 === undefined) {
                throw new RequiredError('bodyCreateCustomerOrganizationV1','Required parameter bodyCreateCustomerOrganizationV1 was null or undefined when calling createCustomerOrganizationV1.');
            }
            const localVarPath = `/v1/resellers/customers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyCreateCustomerOrganizationV1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyCreateCustomerOrganizationV1 !== undefined ? bodyCreateCustomerOrganizationV1 : {}) : (bodyCreateCustomerOrganizationV1 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
         * @summary Create Reseller Organization
         * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResellerOrganizationV1: async (bodyCreateResellerOrganizationV1: BodyCreateResellerOrganizationV1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateResellerOrganizationV1' is not null or undefined
            if (bodyCreateResellerOrganizationV1 === null || bodyCreateResellerOrganizationV1 === undefined) {
                throw new RequiredError('bodyCreateResellerOrganizationV1','Required parameter bodyCreateResellerOrganizationV1 was null or undefined when calling createResellerOrganizationV1.');
            }
            const localVarPath = `/v1/resellers/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyCreateResellerOrganizationV1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyCreateResellerOrganizationV1 !== undefined ? bodyCreateResellerOrganizationV1 : {}) : (bodyCreateResellerOrganizationV1 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user
         * @summary Delete Reseller User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerUserV1: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteResellerUserV1.');
            }
            const localVarPath = `/v1/resellers/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
         * @summary Get Customer Credentials
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCredentialsV1: async (customerOrgId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling getCustomerCredentialsV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}/credentials`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get customer credits
         * @summary Get Customer Credits
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCreditsV1: async (customerOrgId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling getCustomerCreditsV1.');
            }
            const localVarPath = `/v1/resellers/customer/{customer_org_id}/credits`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a customer organization by id under a reseller organization
         * @summary Get Customer Org
         * @param {string} customerOrgId 
         * @param {boolean} [includeUsers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerOrganizationV1: async (customerOrgId: string, includeUsers?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling getCustomerOrganizationV1.');
            }
            const localVarPath = `/v1/resellers/customers/{customer_org_id}`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (includeUsers !== undefined) {
                localVarQueryParameter['include_users'] = includeUsers;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization settings
         * @summary Get Organization Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSettingsV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/settings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get analytics data for Reseller
         * @summary Get Reseller Metrics
         * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerMetricsV1: async (resellerBatchMetricsRequests: ResellerBatchMetricsRequests, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resellerBatchMetricsRequests' is not null or undefined
            if (resellerBatchMetricsRequests === null || resellerBatchMetricsRequests === undefined) {
                throw new RequiredError('resellerBatchMetricsRequests','Required parameter resellerBatchMetricsRequests was null or undefined when calling getResellerMetricsV1.');
            }
            const localVarPath = `/v1/resellers/metrics`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof resellerBatchMetricsRequests !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(resellerBatchMetricsRequests !== undefined ? resellerBatchMetricsRequests : {}) : (resellerBatchMetricsRequests || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a reseller organization by id
         * @summary Get Reseller Organization
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerOrganizationV1: async (orgId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            if (orgId === null || orgId === undefined) {
                throw new RequiredError('orgId','Required parameter orgId was null or undefined when calling getResellerOrganizationV1.');
            }
            const localVarPath = `/v1/resellers/organizations/{org_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get reseller pricing for customer
         * @summary Get Reseller Pricing
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerPricingV1: async (customerOrgId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling getResellerPricingV1.');
            }
            const localVarPath = `/v1/resellers/customer/{customer_org_id}/pricing`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all the customer organizations under a reseller organization
         * @summary List Customers
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomerOrganizationsV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/customers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of all open invites from the organization
         * @summary List Reseller User Invites
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUserInvitesV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/invites`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all users under the user\'s organization
         * @summary List Reseller Users
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUsersV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Invite Users
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendResellerUserInviteV1: async (guestInput: GuestInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guestInput' is not null or undefined
            if (guestInput === null || guestInput === undefined) {
                throw new RequiredError('guestInput','Required parameter guestInput was null or undefined when calling sendResellerUserInviteV1.');
            }
            const localVarPath = `/v1/resellers/invites`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof guestInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(guestInput !== undefined ? guestInput : {}) : (guestInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sync reseller stripe customer
         * @summary Stripe Sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeSyncV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/resellers/settings/stripe-sync`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update customer pricing
         * @summary Reseller Customer Pricing Update
         * @param {string} customerOrgId 
         * @param {Array<PriceUpdateRequest>} priceUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerPricingV1: async (customerOrgId: string, priceUpdateRequest: Array<PriceUpdateRequest>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerOrgId' is not null or undefined
            if (customerOrgId === null || customerOrgId === undefined) {
                throw new RequiredError('customerOrgId','Required parameter customerOrgId was null or undefined when calling updateCustomerPricingV1.');
            }
            // verify required parameter 'priceUpdateRequest' is not null or undefined
            if (priceUpdateRequest === null || priceUpdateRequest === undefined) {
                throw new RequiredError('priceUpdateRequest','Required parameter priceUpdateRequest was null or undefined when calling updateCustomerPricingV1.');
            }
            const localVarPath = `/v1/resellers/customer/{customer_org_id}/pricing`
                .replace(`{${"customer_org_id"}}`, encodeURIComponent(String(customerOrgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof priceUpdateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(priceUpdateRequest !== undefined ? priceUpdateRequest : {}) : (priceUpdateRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a reseller organization
         * @summary Update Reseller Organization
         * @param {string} orgId 
         * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerOrganizationV1: async (orgId: string, updateResellerOrganizationRequest: UpdateResellerOrganizationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            if (orgId === null || orgId === undefined) {
                throw new RequiredError('orgId','Required parameter orgId was null or undefined when calling updateResellerOrganizationV1.');
            }
            // verify required parameter 'updateResellerOrganizationRequest' is not null or undefined
            if (updateResellerOrganizationRequest === null || updateResellerOrganizationRequest === undefined) {
                throw new RequiredError('updateResellerOrganizationRequest','Required parameter updateResellerOrganizationRequest was null or undefined when calling updateResellerOrganizationV1.');
            }
            const localVarPath = `/v1/resellers/organizations/{org_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateResellerOrganizationRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateResellerOrganizationRequest !== undefined ? updateResellerOrganizationRequest : {}) : (updateResellerOrganizationRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update organization settings
         * @summary Organization Settings Update
         * @param {OrganizationSettings} organizationSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerSettingsV1: async (organizationSettings: OrganizationSettings, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSettings' is not null or undefined
            if (organizationSettings === null || organizationSettings === undefined) {
                throw new RequiredError('organizationSettings','Required parameter organizationSettings was null or undefined when calling updateResellerSettingsV1.');
            }
            const localVarPath = `/v1/resellers/settings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof organizationSettings !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(organizationSettings !== undefined ? organizationSettings : {}) : (organizationSettings || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user details
         * @summary Update Reseller User
         * @param {string} userId 
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerUserV1: async (userId: string, updateUserPayload: UpdateUserPayload, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateResellerUserV1.');
            }
            // verify required parameter 'updateUserPayload' is not null or undefined
            if (updateUserPayload === null || updateUserPayload === undefined) {
                throw new RequiredError('updateUserPayload','Required parameter updateUserPayload was null or undefined when calling updateResellerUserV1.');
            }
            const localVarPath = `/v1/resellers/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateUserPayload !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateUserPayload !== undefined ? updateUserPayload : {}) : (updateUserPayload || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerApi - functional programming interface
 * @export
 */
export const ResellerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Accept Invite
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptResellerUserInviteV1(acceptInviteRequest: AcceptInviteRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).acceptResellerUserInviteV1(acceptInviteRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add customer credit
         * @summary Add Customer Credit
         * @param {string} customerOrgId 
         * @param {Array<CustomerCreditRequest>} customerCreditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCustomerCreditV1(customerOrgId: string, customerCreditRequest: Array<CustomerCreditRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).addCustomerCreditV1(customerOrgId, customerCreditRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add Reseller settings
         * @summary Organization Settings
         * @param {OrganizationSettings} organizationSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addResellerSettingsV1(organizationSettings: OrganizationSettings, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSettings>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).addResellerSettingsV1(organizationSettings, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new customer organization under a reseller organization
         * @summary Create Customer
         * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1: BodyCreateCustomerOrganizationV1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
         * @summary Create Reseller Organization
         * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResellerOrganizationV1(bodyCreateResellerOrganizationV1: BodyCreateResellerOrganizationV1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a user
         * @summary Delete Reseller User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResellerUserV1(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).deleteResellerUserV1(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
         * @summary Get Customer Credentials
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerCredentialsV1(customerOrgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).getCustomerCredentialsV1(customerOrgId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get customer credits
         * @summary Get Customer Credits
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerCreditsV1(customerOrgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Credit>>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).getCustomerCreditsV1(customerOrgId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a customer organization by id under a reseller organization
         * @summary Get Customer Org
         * @param {string} customerOrgId 
         * @param {boolean} [includeUsers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerOrganizationV1(customerOrgId: string, includeUsers?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrgUsersPriceCredits>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).getCustomerOrganizationV1(customerOrgId, includeUsers, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get organization settings
         * @summary Get Organization Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationSettingsV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSettings>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).getOrganizationSettingsV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get analytics data for Reseller
         * @summary Get Reseller Metrics
         * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResellerMetricsV1(resellerBatchMetricsRequests: ResellerBatchMetricsRequests, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchMetricsResponse>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).getResellerMetricsV1(resellerBatchMetricsRequests, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a reseller organization by id
         * @summary Get Reseller Organization
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResellerOrganizationV1(orgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrgWithUsers>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).getResellerOrganizationV1(orgId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get reseller pricing for customer
         * @summary Get Reseller Pricing
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResellerPricingV1(customerOrgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlanDetails>>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).getResellerPricingV1(customerOrgId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all the customer organizations under a reseller organization
         * @summary List Customers
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCustomerOrganizationsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrgUsersPriceCredits>>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).listCustomerOrganizationsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List of all open invites from the organization
         * @summary List Reseller User Invites
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResellerUserInvitesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuestOutput>>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all users under the user\'s organization
         * @summary List Reseller Users
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResellerUsersV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Invite Users
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendResellerUserInviteV1(guestInput: GuestInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuestOutput>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).sendResellerUserInviteV1(guestInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sync reseller stripe customer
         * @summary Stripe Sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeSyncV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).stripeSyncV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update customer pricing
         * @summary Reseller Customer Pricing Update
         * @param {string} customerOrgId 
         * @param {Array<PriceUpdateRequest>} priceUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomerPricingV1(customerOrgId: string, priceUpdateRequest: Array<PriceUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).updateCustomerPricingV1(customerOrgId, priceUpdateRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a reseller organization
         * @summary Update Reseller Organization
         * @param {string} orgId 
         * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResellerOrganizationV1(orgId: string, updateResellerOrganizationRequest: UpdateResellerOrganizationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationOutput>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).updateResellerOrganizationV1(orgId, updateResellerOrganizationRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update organization settings
         * @summary Organization Settings Update
         * @param {OrganizationSettings} organizationSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResellerSettingsV1(organizationSettings: OrganizationSettings, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSettings>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).updateResellerSettingsV1(organizationSettings, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update user details
         * @summary Update Reseller User
         * @param {string} userId 
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResellerUserV1(userId: string, updateUserPayload: UpdateUserPayload, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await ResellerApiAxiosParamCreator(configuration).updateResellerUserV1(userId, updateUserPayload, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ResellerApi - factory interface
 * @export
 */
export const ResellerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Accept invite and add new user to organization
         * @summary Accept Invite
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptResellerUserInviteV1(acceptInviteRequest: AcceptInviteRequest, options?: any): AxiosPromise<User> {
            return ResellerApiFp(configuration).acceptResellerUserInviteV1(acceptInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add customer credit
         * @summary Add Customer Credit
         * @param {string} customerOrgId 
         * @param {Array<CustomerCreditRequest>} customerCreditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCustomerCreditV1(customerOrgId: string, customerCreditRequest: Array<CustomerCreditRequest>, options?: any): AxiosPromise<BaseResponse> {
            return ResellerApiFp(configuration).addCustomerCreditV1(customerOrgId, customerCreditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add Reseller settings
         * @summary Organization Settings
         * @param {OrganizationSettings} organizationSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResellerSettingsV1(organizationSettings: OrganizationSettings, options?: any): AxiosPromise<OrganizationSettings> {
            return ResellerApiFp(configuration).addResellerSettingsV1(organizationSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new customer organization under a reseller organization
         * @summary Create Customer
         * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1: BodyCreateCustomerOrganizationV1, options?: any): AxiosPromise<User> {
            return ResellerApiFp(configuration).createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
         * @summary Create Reseller Organization
         * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResellerOrganizationV1(bodyCreateResellerOrganizationV1: BodyCreateResellerOrganizationV1, options?: any): AxiosPromise<User> {
            return ResellerApiFp(configuration).createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user
         * @summary Delete Reseller User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResellerUserV1(userId: string, options?: any): AxiosPromise<User> {
            return ResellerApiFp(configuration).deleteResellerUserV1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
         * @summary Get Customer Credentials
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCredentialsV1(customerOrgId: string, options?: any): AxiosPromise<string> {
            return ResellerApiFp(configuration).getCustomerCredentialsV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get customer credits
         * @summary Get Customer Credits
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCreditsV1(customerOrgId: string, options?: any): AxiosPromise<Array<Credit>> {
            return ResellerApiFp(configuration).getCustomerCreditsV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a customer organization by id under a reseller organization
         * @summary Get Customer Org
         * @param {string} customerOrgId 
         * @param {boolean} [includeUsers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerOrganizationV1(customerOrgId: string, includeUsers?: boolean, options?: any): AxiosPromise<OrgUsersPriceCredits> {
            return ResellerApiFp(configuration).getCustomerOrganizationV1(customerOrgId, includeUsers, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization settings
         * @summary Get Organization Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSettingsV1(options?: any): AxiosPromise<OrganizationSettings> {
            return ResellerApiFp(configuration).getOrganizationSettingsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Get analytics data for Reseller
         * @summary Get Reseller Metrics
         * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerMetricsV1(resellerBatchMetricsRequests: ResellerBatchMetricsRequests, options?: any): AxiosPromise<BatchMetricsResponse> {
            return ResellerApiFp(configuration).getResellerMetricsV1(resellerBatchMetricsRequests, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a reseller organization by id
         * @summary Get Reseller Organization
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerOrganizationV1(orgId: string, options?: any): AxiosPromise<OrgWithUsers> {
            return ResellerApiFp(configuration).getResellerOrganizationV1(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get reseller pricing for customer
         * @summary Get Reseller Pricing
         * @param {string} customerOrgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResellerPricingV1(customerOrgId: string, options?: any): AxiosPromise<Array<PlanDetails>> {
            return ResellerApiFp(configuration).getResellerPricingV1(customerOrgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the customer organizations under a reseller organization
         * @summary List Customers
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomerOrganizationsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<OrgUsersPriceCredits>> {
            return ResellerApiFp(configuration).listCustomerOrganizationsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * List of all open invites from the organization
         * @summary List Reseller User Invites
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUserInvitesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<GuestOutput>> {
            return ResellerApiFp(configuration).listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all users under the user\'s organization
         * @summary List Reseller Users
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResellerUsersV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return ResellerApiFp(configuration).listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a new user to an organization or resend invite to the user if the user is already invited
         * @summary Invite Users
         * @param {GuestInput} guestInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendResellerUserInviteV1(guestInput: GuestInput, options?: any): AxiosPromise<GuestOutput> {
            return ResellerApiFp(configuration).sendResellerUserInviteV1(guestInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync reseller stripe customer
         * @summary Stripe Sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeSyncV1(options?: any): AxiosPromise<BaseResponse> {
            return ResellerApiFp(configuration).stripeSyncV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Update customer pricing
         * @summary Reseller Customer Pricing Update
         * @param {string} customerOrgId 
         * @param {Array<PriceUpdateRequest>} priceUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerPricingV1(customerOrgId: string, priceUpdateRequest: Array<PriceUpdateRequest>, options?: any): AxiosPromise<BaseResponse> {
            return ResellerApiFp(configuration).updateCustomerPricingV1(customerOrgId, priceUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a reseller organization
         * @summary Update Reseller Organization
         * @param {string} orgId 
         * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerOrganizationV1(orgId: string, updateResellerOrganizationRequest: UpdateResellerOrganizationRequest, options?: any): AxiosPromise<OrganizationOutput> {
            return ResellerApiFp(configuration).updateResellerOrganizationV1(orgId, updateResellerOrganizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update organization settings
         * @summary Organization Settings Update
         * @param {OrganizationSettings} organizationSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerSettingsV1(organizationSettings: OrganizationSettings, options?: any): AxiosPromise<OrganizationSettings> {
            return ResellerApiFp(configuration).updateResellerSettingsV1(organizationSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user details
         * @summary Update Reseller User
         * @param {string} userId 
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResellerUserV1(userId: string, updateUserPayload: UpdateUserPayload, options?: any): AxiosPromise<User> {
            return ResellerApiFp(configuration).updateResellerUserV1(userId, updateUserPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResellerApi - object-oriented interface
 * @export
 * @class ResellerApi
 * @extends {BaseAPI}
 */
export class ResellerApi extends BaseAPI {
    /**
     * Accept invite and add new user to organization
     * @summary Accept Invite
     * @param {AcceptInviteRequest} acceptInviteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public acceptResellerUserInviteV1(acceptInviteRequest: AcceptInviteRequest, options?: any) {
        return ResellerApiFp(this.configuration).acceptResellerUserInviteV1(acceptInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add customer credit
     * @summary Add Customer Credit
     * @param {string} customerOrgId 
     * @param {Array<CustomerCreditRequest>} customerCreditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public addCustomerCreditV1(customerOrgId: string, customerCreditRequest: Array<CustomerCreditRequest>, options?: any) {
        return ResellerApiFp(this.configuration).addCustomerCreditV1(customerOrgId, customerCreditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add Reseller settings
     * @summary Organization Settings
     * @param {OrganizationSettings} organizationSettings 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public addResellerSettingsV1(organizationSettings: OrganizationSettings, options?: any) {
        return ResellerApiFp(this.configuration).addResellerSettingsV1(organizationSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new customer organization under a reseller organization
     * @summary Create Customer
     * @param {BodyCreateCustomerOrganizationV1} bodyCreateCustomerOrganizationV1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1: BodyCreateCustomerOrganizationV1, options?: any) {
        return ResellerApiFp(this.configuration).createCustomerOrganizationV1(bodyCreateCustomerOrganizationV1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new reseller organization and adds the created user as the \'ADMIN\' user for the org
     * @summary Create Reseller Organization
     * @param {BodyCreateResellerOrganizationV1} bodyCreateResellerOrganizationV1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public createResellerOrganizationV1(bodyCreateResellerOrganizationV1: BodyCreateResellerOrganizationV1, options?: any) {
        return ResellerApiFp(this.configuration).createResellerOrganizationV1(bodyCreateResellerOrganizationV1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user
     * @summary Delete Reseller User
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public deleteResellerUserV1(userId: string, options?: any) {
        return ResellerApiFp(this.configuration).deleteResellerUserV1(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the customer org credentials for a customer organization under a reseller organization. NOTE: This will only return the custom token of the reseller admin user present in the customer org. Exchange this token with the id token to use it as a firebase credential in the client side.
     * @summary Get Customer Credentials
     * @param {string} customerOrgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public getCustomerCredentialsV1(customerOrgId: string, options?: any) {
        return ResellerApiFp(this.configuration).getCustomerCredentialsV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get customer credits
     * @summary Get Customer Credits
     * @param {string} customerOrgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public getCustomerCreditsV1(customerOrgId: string, options?: any) {
        return ResellerApiFp(this.configuration).getCustomerCreditsV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a customer organization by id under a reseller organization
     * @summary Get Customer Org
     * @param {string} customerOrgId 
     * @param {boolean} [includeUsers] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public getCustomerOrganizationV1(customerOrgId: string, includeUsers?: boolean, options?: any) {
        return ResellerApiFp(this.configuration).getCustomerOrganizationV1(customerOrgId, includeUsers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization settings
     * @summary Get Organization Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public getOrganizationSettingsV1(options?: any) {
        return ResellerApiFp(this.configuration).getOrganizationSettingsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get analytics data for Reseller
     * @summary Get Reseller Metrics
     * @param {ResellerBatchMetricsRequests} resellerBatchMetricsRequests 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public getResellerMetricsV1(resellerBatchMetricsRequests: ResellerBatchMetricsRequests, options?: any) {
        return ResellerApiFp(this.configuration).getResellerMetricsV1(resellerBatchMetricsRequests, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a reseller organization by id
     * @summary Get Reseller Organization
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public getResellerOrganizationV1(orgId: string, options?: any) {
        return ResellerApiFp(this.configuration).getResellerOrganizationV1(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get reseller pricing for customer
     * @summary Get Reseller Pricing
     * @param {string} customerOrgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public getResellerPricingV1(customerOrgId: string, options?: any) {
        return ResellerApiFp(this.configuration).getResellerPricingV1(customerOrgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all the customer organizations under a reseller organization
     * @summary List Customers
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public listCustomerOrganizationsV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return ResellerApiFp(this.configuration).listCustomerOrganizationsV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of all open invites from the organization
     * @summary List Reseller User Invites
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public listResellerUserInvitesV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return ResellerApiFp(this.configuration).listResellerUserInvitesV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all users under the user\'s organization
     * @summary List Reseller Users
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public listResellerUsersV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, options?: any) {
        return ResellerApiFp(this.configuration).listResellerUsersV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a new user to an organization or resend invite to the user if the user is already invited
     * @summary Invite Users
     * @param {GuestInput} guestInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public sendResellerUserInviteV1(guestInput: GuestInput, options?: any) {
        return ResellerApiFp(this.configuration).sendResellerUserInviteV1(guestInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sync reseller stripe customer
     * @summary Stripe Sync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public stripeSyncV1(options?: any) {
        return ResellerApiFp(this.configuration).stripeSyncV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update customer pricing
     * @summary Reseller Customer Pricing Update
     * @param {string} customerOrgId 
     * @param {Array<PriceUpdateRequest>} priceUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public updateCustomerPricingV1(customerOrgId: string, priceUpdateRequest: Array<PriceUpdateRequest>, options?: any) {
        return ResellerApiFp(this.configuration).updateCustomerPricingV1(customerOrgId, priceUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a reseller organization
     * @summary Update Reseller Organization
     * @param {string} orgId 
     * @param {UpdateResellerOrganizationRequest} updateResellerOrganizationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public updateResellerOrganizationV1(orgId: string, updateResellerOrganizationRequest: UpdateResellerOrganizationRequest, options?: any) {
        return ResellerApiFp(this.configuration).updateResellerOrganizationV1(orgId, updateResellerOrganizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update organization settings
     * @summary Organization Settings Update
     * @param {OrganizationSettings} organizationSettings 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public updateResellerSettingsV1(organizationSettings: OrganizationSettings, options?: any) {
        return ResellerApiFp(this.configuration).updateResellerSettingsV1(organizationSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user details
     * @summary Update Reseller User
     * @param {string} userId 
     * @param {UpdateUserPayload} updateUserPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerApi
     */
    public updateResellerUserV1(userId: string, updateUserPayload: UpdateUserPayload, options?: any) {
        return ResellerApiFp(this.configuration).updateResellerUserV1(userId, updateUserPayload, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TelephonyApi - axios parameter creator
 * @export
 */
export const TelephonyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Agent Phones
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentPhonesV1: async (agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling getAgentPhonesV1.');
            }
            const localVarPath = `/v1/ai-agents/{agent_id}/phones`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Link Phone To Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPhoneToAgentV1: async (phoneId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'phoneId' is not null or undefined
            if (phoneId === null || phoneId === undefined) {
                throw new RequiredError('phoneId','Required parameter phoneId was null or undefined when calling linkPhoneToAgentV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling linkPhoneToAgentV1.');
            }
            const localVarPath = `/v1/telephony/phones/{phone_id}/ai-agents/{agent_id}/link`
                .replace(`{${"phone_id"}}`, encodeURIComponent(String(phoneId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Available Phones
         * @param {string} countryCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailablePhonesV1: async (countryCode: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryCode' is not null or undefined
            if (countryCode === null || countryCode === undefined) {
                throw new RequiredError('countryCode','Required parameter countryCode was null or undefined when calling listAvailablePhonesV1.');
            }
            const localVarPath = `/v1/telephony/countries/{country_code}/available-phones`
                .replace(`{${"country_code"}}`, encodeURIComponent(String(countryCode)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Purchased Phones
         * @param {string} [countryCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPurchasedPhonesV1: async (countryCode?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/telephony/phones`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Supported Countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupportedCountriesV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/telephony/countries`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purchase Phone
         * @param {NumberPurchaseRequest} numberPurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasePhoneV1: async (numberPurchaseRequest: NumberPurchaseRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'numberPurchaseRequest' is not null or undefined
            if (numberPurchaseRequest === null || numberPurchaseRequest === undefined) {
                throw new RequiredError('numberPurchaseRequest','Required parameter numberPurchaseRequest was null or undefined when calling purchasePhoneV1.');
            }
            const localVarPath = `/v1/telephony/phones`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof numberPurchaseRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(numberPurchaseRequest !== undefined ? numberPurchaseRequest : {}) : (numberPurchaseRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Release Phone
         * @param {string} phoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePhoneV1: async (phoneId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'phoneId' is not null or undefined
            if (phoneId === null || phoneId === undefined) {
                throw new RequiredError('phoneId','Required parameter phoneId was null or undefined when calling releasePhoneV1.');
            }
            const localVarPath = `/v1/telephony/phones/{phone_id}`
                .replace(`{${"phone_id"}}`, encodeURIComponent(String(phoneId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlink Phone From Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPhoneFromAgentV1: async (phoneId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'phoneId' is not null or undefined
            if (phoneId === null || phoneId === undefined) {
                throw new RequiredError('phoneId','Required parameter phoneId was null or undefined when calling unlinkPhoneFromAgentV1.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling unlinkPhoneFromAgentV1.');
            }
            const localVarPath = `/v1/telephony/phones/{phone_id}/ai-agents/{agent_id}/link`
                .replace(`{${"phone_id"}}`, encodeURIComponent(String(phoneId)))
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TelephonyApi - functional programming interface
 * @export
 */
export const TelephonyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Agent Phones
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAgentPhonesV1(agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TelephoneNumber>>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).getAgentPhonesV1(agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Link Phone To Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkPhoneToAgentV1(phoneId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).linkPhoneToAgentV1(phoneId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Available Phones
         * @param {string} countryCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAvailablePhonesV1(countryCode: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AvailablePhoneNumber>>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).listAvailablePhonesV1(countryCode, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Purchased Phones
         * @param {string} [countryCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPurchasedPhonesV1(countryCode?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TelephoneNumber>>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).listPurchasedPhonesV1(countryCode, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Supported Countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSupportedCountriesV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CountryInfo>>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).listSupportedCountriesV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Purchase Phone
         * @param {NumberPurchaseRequest} numberPurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchasePhoneV1(numberPurchaseRequest: NumberPurchaseRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TelephoneNumber>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).purchasePhoneV1(numberPurchaseRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Release Phone
         * @param {string} phoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async releasePhoneV1(phoneId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).releasePhoneV1(phoneId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Unlink Phone From Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkPhoneFromAgentV1(phoneId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await TelephonyApiAxiosParamCreator(configuration).unlinkPhoneFromAgentV1(phoneId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TelephonyApi - factory interface
 * @export
 */
export const TelephonyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get Agent Phones
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentPhonesV1(agentId: string, options?: any): AxiosPromise<Array<TelephoneNumber>> {
            return TelephonyApiFp(configuration).getAgentPhonesV1(agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Link Phone To Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPhoneToAgentV1(phoneId: string, agentId: string, options?: any): AxiosPromise<BaseResponse> {
            return TelephonyApiFp(configuration).linkPhoneToAgentV1(phoneId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Available Phones
         * @param {string} countryCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailablePhonesV1(countryCode: string, options?: any): AxiosPromise<Array<AvailablePhoneNumber>> {
            return TelephonyApiFp(configuration).listAvailablePhonesV1(countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Purchased Phones
         * @param {string} [countryCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPurchasedPhonesV1(countryCode?: string, options?: any): AxiosPromise<Array<TelephoneNumber>> {
            return TelephonyApiFp(configuration).listPurchasedPhonesV1(countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Supported Countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupportedCountriesV1(options?: any): AxiosPromise<Array<CountryInfo>> {
            return TelephonyApiFp(configuration).listSupportedCountriesV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purchase Phone
         * @param {NumberPurchaseRequest} numberPurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasePhoneV1(numberPurchaseRequest: NumberPurchaseRequest, options?: any): AxiosPromise<TelephoneNumber> {
            return TelephonyApiFp(configuration).purchasePhoneV1(numberPurchaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Release Phone
         * @param {string} phoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePhoneV1(phoneId: string, options?: any): AxiosPromise<BaseResponse> {
            return TelephonyApiFp(configuration).releasePhoneV1(phoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlink Phone From Agent
         * @param {string} phoneId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPhoneFromAgentV1(phoneId: string, agentId: string, options?: any): AxiosPromise<BaseResponse> {
            return TelephonyApiFp(configuration).unlinkPhoneFromAgentV1(phoneId, agentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TelephonyApi - object-oriented interface
 * @export
 * @class TelephonyApi
 * @extends {BaseAPI}
 */
export class TelephonyApi extends BaseAPI {
    /**
     * 
     * @summary Get Agent Phones
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public getAgentPhonesV1(agentId: string, options?: any) {
        return TelephonyApiFp(this.configuration).getAgentPhonesV1(agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Link Phone To Agent
     * @param {string} phoneId 
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public linkPhoneToAgentV1(phoneId: string, agentId: string, options?: any) {
        return TelephonyApiFp(this.configuration).linkPhoneToAgentV1(phoneId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Available Phones
     * @param {string} countryCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public listAvailablePhonesV1(countryCode: string, options?: any) {
        return TelephonyApiFp(this.configuration).listAvailablePhonesV1(countryCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Purchased Phones
     * @param {string} [countryCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public listPurchasedPhonesV1(countryCode?: string, options?: any) {
        return TelephonyApiFp(this.configuration).listPurchasedPhonesV1(countryCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Supported Countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public listSupportedCountriesV1(options?: any) {
        return TelephonyApiFp(this.configuration).listSupportedCountriesV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purchase Phone
     * @param {NumberPurchaseRequest} numberPurchaseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public purchasePhoneV1(numberPurchaseRequest: NumberPurchaseRequest, options?: any) {
        return TelephonyApiFp(this.configuration).purchasePhoneV1(numberPurchaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Release Phone
     * @param {string} phoneId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public releasePhoneV1(phoneId: string, options?: any) {
        return TelephonyApiFp(this.configuration).releasePhoneV1(phoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlink Phone From Agent
     * @param {string} phoneId 
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelephonyApi
     */
    public unlinkPhoneFromAgentV1(phoneId: string, agentId: string, options?: any) {
        return TelephonyApiFp(this.configuration).unlinkPhoneFromAgentV1(phoneId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * UIApi - axios parameter creator
 * @export
 */
export const UIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Action Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionTemplatesV1: async (language?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ui/action-templates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Products
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {Array<string>} [tags] Filter products by specific tags
         * @param {Array<string>} [productIds] Filter by specific product IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsDetailedV1: async (searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ui/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['search_by'] = searchBy;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['search_value'] = searchValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (productIds) {
                localVarQueryParameter['product_ids'] = productIds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Prompt Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptTemplatesV1: async (language?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ui/prompt-templates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Role Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleTemplatesV1: async (language?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ui/role-templates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UIApi - functional programming interface
 * @export
 */
export const UIApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Action Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActionTemplatesV1(language?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActionInput>>> {
            const localVarAxiosArgs = await UIApiAxiosParamCreator(configuration).listActionTemplatesV1(language, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Products
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {Array<string>} [tags] Filter products by specific tags
         * @param {Array<string>} [productIds] Filter by specific product IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProductsDetailedV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductWithAgents>>> {
            const localVarAxiosArgs = await UIApiAxiosParamCreator(configuration).listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Prompt Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPromptTemplatesV1(language?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: PromptTemplate; }>> {
            const localVarAxiosArgs = await UIApiAxiosParamCreator(configuration).listPromptTemplatesV1(language, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Role Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoleTemplatesV1(language?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleTemplate>>> {
            const localVarAxiosArgs = await UIApiAxiosParamCreator(configuration).listRoleTemplatesV1(language, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UIApi - factory interface
 * @export
 */
export const UIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary List Action Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionTemplatesV1(language?: string, options?: any): AxiosPromise<Array<ActionInput>> {
            return UIApiFp(configuration).listActionTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Products
         * @param {string} [searchBy] Field name to search by
         * @param {string} [searchValue] Value to search for in the specified field
         * @param {string} [status] Filter by status
         * @param {string} [sortBy] Field to sort by
         * @param {SortOrder} [sortOrder] Sort order (asc or desc)
         * @param {number} [skip] Number of records to skip
         * @param {number} [limit] Maximum number of records to return
         * @param {Array<string>} [tags] Filter products by specific tags
         * @param {Array<string>} [productIds] Filter by specific product IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductsDetailedV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options?: any): AxiosPromise<Array<ProductWithAgents>> {
            return UIApiFp(configuration).listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Prompt Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptTemplatesV1(language?: string, options?: any): AxiosPromise<{ [key: string]: PromptTemplate; }> {
            return UIApiFp(configuration).listPromptTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Role Templates
         * @param {string} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleTemplatesV1(language?: string, options?: any): AxiosPromise<Array<RoleTemplate>> {
            return UIApiFp(configuration).listRoleTemplatesV1(language, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UIApi - object-oriented interface
 * @export
 * @class UIApi
 * @extends {BaseAPI}
 */
export class UIApi extends BaseAPI {
    /**
     * 
     * @summary List Action Templates
     * @param {string} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    public listActionTemplatesV1(language?: string, options?: any) {
        return UIApiFp(this.configuration).listActionTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Products
     * @param {string} [searchBy] Field name to search by
     * @param {string} [searchValue] Value to search for in the specified field
     * @param {string} [status] Filter by status
     * @param {string} [sortBy] Field to sort by
     * @param {SortOrder} [sortOrder] Sort order (asc or desc)
     * @param {number} [skip] Number of records to skip
     * @param {number} [limit] Maximum number of records to return
     * @param {Array<string>} [tags] Filter products by specific tags
     * @param {Array<string>} [productIds] Filter by specific product IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    public listProductsDetailedV1(searchBy?: string, searchValue?: string, status?: string, sortBy?: string, sortOrder?: SortOrder, skip?: number, limit?: number, tags?: Array<string>, productIds?: Array<string>, options?: any) {
        return UIApiFp(this.configuration).listProductsDetailedV1(searchBy, searchValue, status, sortBy, sortOrder, skip, limit, tags, productIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Prompt Templates
     * @param {string} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    public listPromptTemplatesV1(language?: string, options?: any) {
        return UIApiFp(this.configuration).listPromptTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Role Templates
     * @param {string} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UIApi
     */
    public listRoleTemplatesV1(language?: string, options?: any) {
        return UIApiFp(this.configuration).listRoleTemplatesV1(language, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * VoiceModelsApi - axios parameter creator
 * @export
 */
export const VoiceModelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get list of voices available for calls
         * @summary Get list of voices available for calls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoiceModelsV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/voice-models`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VoiceModelsApi - functional programming interface
 * @export
 */
export const VoiceModelsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get list of voices available for calls
         * @summary Get list of voices available for calls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVoiceModelsV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VoiceModel>>> {
            const localVarAxiosArgs = await VoiceModelsApiAxiosParamCreator(configuration).listVoiceModelsV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VoiceModelsApi - factory interface
 * @export
 */
export const VoiceModelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get list of voices available for calls
         * @summary Get list of voices available for calls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoiceModelsV1(options?: any): AxiosPromise<Array<VoiceModel>> {
            return VoiceModelsApiFp(configuration).listVoiceModelsV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VoiceModelsApi - object-oriented interface
 * @export
 * @class VoiceModelsApi
 * @extends {BaseAPI}
 */
export class VoiceModelsApi extends BaseAPI {
    /**
     * Get list of voices available for calls
     * @summary Get list of voices available for calls
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceModelsApi
     */
    public listVoiceModelsV1(options?: any) {
        return VoiceModelsApiFp(this.configuration).listVoiceModelsV1(options).then((request) => request(this.axios, this.basePath));
    }

}


